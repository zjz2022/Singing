## 对象

### 3.1 Javascript 创建对象的几种方式？

1. 简单对象的创建 使用对象字面量的方式{}

```javascript
const Cat = {};
```

2. new 一个function

```javascript
function Person(){
}
const personOne=new Person();
```

3. 使用工厂方式来创建（Object 关键字）

```javascript
const wcDog =new Object();
```

4. 使用 Object.create() 创建对象（使用现有对象作为原型）

```javascript
const person = Object.create(anotherPerson);
```

5. 使用 ES6 中的类（Class）创建对象（其实质还是使用构造函数）：

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}
const person = new Person('John');
```

### 3.2 如何区分数组和对象？

1. 通过 ES6 中的 Array.isArray

```javascript
Array.isArray([]) //true
Array.isArray({}) //false
```

2. 通过 instanceof 来识别

```javascript
[] instanceof Array //true
{} instanceof Array //false
```

3. 通过调用 constructor 来识别

```javascript
{}.constructor //返回 object
[].constructor //返回 Array
```

4. 通过 Object.prototype.toString.call 方法来识别

```javascript
Object.prototype.toString.call([]) //["object Array"]
Object.prototype.toString.call({}) //["object Object"]
```

### 3.3 把一个对象a的值赋给对象b的值，然后去改变b里面的一个属性，a的属性会发生变化吗？

### 3.4 如何判断对象是不是空对象

### 3.5 JavaScript 中如何对一个对象进行深度 clone

  浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个 地址，**就会影响到另一个对象。**  

​      深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后**两个对象互不影响。** 

javaScript数据类型分为以下两类：

​    **值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。

​    **引用数据类型（对象类型）**：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。

有个问题：

为什么要进行深度拷贝呢？直接赋值不可以吗？

​    值类型是不分什么[深拷贝浅拷贝](https://so.csdn.net/so/search?q=深拷贝浅拷贝&spm=1002103007020)的。

​    **引用数据类型**要明白一点，[引用数据类型](https://so.csdn.net/so/search?q=引用数据类型&spm=1002103007020)在值传递的时候，传递的是内存地址

> var a = [ 1, 2 ]
>
> ​    var b = a
>
> ​    b[1] = 0
>
> ​    console.log(a)  //打印结果为[ 0, 2 ]

**b = a** 是将**a**的内存地址赋给了**b ,**此时**a**和**b**指向的是同一个内存地址**，b**值的改变会影响到**a**



​    现写一个方法对一个引用数据类型进行深拷贝。（就是一层一层地扒开，一直到值类型，再进行[值传递](https://so.csdn.net/so/search?q=值传递&spm=1002103007020)。）

```html
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="UTF-8" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <meta name="viewport" content="width=device-width, initial-scale=0" />

    <title>Document</title>
  </head>

  <body>
    <script>
      function cloneObj(obj) {
        if (typeof obj == 'object') {
          if (obj instanceof Array) {
            var result = []

            for (var i = 0; i < obj.length; i++) {
              result[i] = cloneObj(obj[i])
            }

            return result
          } else {
            var result = {}

            for (var i in obj) {
              result[i] = cloneObj(obj[i])
            }

            return result
          }
        } else {
          return obj
        }
      }

      var obj1 = [12, { a: 11, b: 22 }, 5]

      var obj2 = cloneObj(obj1)

      obj2[1].a += 100 //改变obj2,看是否影响到了a

      console.log(obj1)

      console.log(obj2)
    </script>
  </body>
</html>
```

### 3.5 解构赋值 结构对象

在 JavaScript 中，结构对象或称解构赋值是一种非常方便的赋值方式。它允许我们将数据结构进行解构，然后将解构出的数据赋值到声明的变量中。

对象解构的基础用法如下：

```javascript
let obj = { a: 1, b: 2, c: 3 };

let { a, b, c } = obj;

console.log(a); // => 1
console.log(b); // => 2
console.log(c); // => 3
```

这段代码中，我们声明了一个对象 `obj`，然后通过解构赋值将 `obj` 的属性 `a`、`b`、`c` 的值赋值给了同名变量 `a`、`b`、`c`。

此外，解构赋值还允许我们为不存在的属性提供默认值：

```javascript
let obj = { a: 1, b: 2 };

let { a = 10, b = 20, c = 30 } = obj;

console.log(a); // => 1
console.log(b); // => 2
console.log(c); // => 30
```

在这段代码中，我们为 `a`、`b`、`c` 提供了默认值。当解构出的属性不存在时，就会使用默认值。

以上就是关于在 JavaScript 中结构对象的简单介绍，解构赋值是 ES6 引入的一个非常强大的新特性，它可以极大地提高我们的编程效率。

### 3.6 对象调用问题

### 3.7 对象与对象属性的存储问题

为什么要涉及堆内存与栈内存，垃圾回收与它们的关系

### 3.8 面向对象与面向过程的区别





## 为什么不使用 toString 而是 Object.prototype.toString()

对于JavaScript对象，通常我们可以直接调用 toString() 方法，例如 'test'.toString() 或者 (123).toString()。但是，当我们想确定一个变量的类型时，我们通不能直接使用 toString() 方法。

这是因为许多对象会覆盖默认的 toString() 方法。例如，数组，日期，和其他内置对象都有自己的 toString() 方法，这些方法返回的是对象的内容、日期的字符串表示等，并不反映对象的实际类型。

例如，[1, 2, 3].toString() 返回的是 '1,2,3' ，这并没有告诉我们对象的类型。

而 Object.prototype.toString.call() 方法可以给我们提供更准确的类型信息，该方法将返回一个表示对象类型的字符串。例如 Object.prototype.toString.call([1, 2, 3]) 返回的就是 '[object Array]'，这样我们就可以知道这个对象的类型是Array。

这就是为什么有时候在需要精确判断一个变量类型时，我们会使用 Object.prototype.toString.call() 而不是直接使用 toString() 方法。