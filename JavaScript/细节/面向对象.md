#  面向对象 

 单例模式 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641296298103-2750a714-c3c9-458e-9ca6-4d7fff23ce61.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641296491758-6d1910b4-b586-483b-8913-f954e0db2efa.webp)



 工厂模式 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641296994284-11f7f166-c777-4e63-bc95-ab3334eedc60.webp)



 构造原型模式 

### (重点)：new的时候不管加不加小括号都是将函数执行了，创建了对应的实例，只不过不加小括号不能传参

### new了一个函数后会发生什么

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641299205748-1f67f464-ed5d-4dbb-8016-b41b0b9e9c44.webp)



### 实例是什么

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641297473750-fac38cf5-73b6-4d44-ac91-4f41db82a02c.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641297459663-65b262bf-00ca-4462-bb5e-b08426f996a2.webp)



### 构造函数return的问题

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641297723538-480a8989-7c72-44ba-909d-26c789b1aeec.webp)



 构造函数习题 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641298599341-e8fe0538-dc19-42cd-aab5-2181917823e7.webp)



解答:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641298948938-c332e6a8-19ac-49a9-9f8c-f5857337e790.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641298984867-d559ed83-99b2-4606-b27d-fe3c64e1ca0f.webp)



 检测对象属性 

 hasOwnProperty 

检测某一个属性名是否为当前对象的私有属性

“in”：检测这个属性是否属于某个对象(不管是私有属性还是公有属性，只要是它的属性。结构就位TRUE)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641379120649-506041c4-84c5-44a2-a453-bb1b56827c61.webp)



### 可以基于内置类原型自己写一个方法hasPubProperty

检测某个属性是否为对象的公有属性

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641379628958-705d0ae1-2568-42a3-9598-fdbaf0b267b0.webp)



 什么是公有什么是私有属性 

自己堆里面有的就是私有属性

需要基于__proto__查找的就是公有属性

(__proto__在IE浏览器中被保护起来了)

 es6创建类Class 

传统创建类的局限性: 由于传统的函数可以扮演三种角色，一种是对象的属性，一种是普通函数执行，一种是构造函数，所以针对性不强

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641468977521-2de9a3ab-905a-4879-b304-1ffe2f29130a.webp)



es6创建类: Class创建的类只能new执行不能当普通函数执行

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641469677502-d786fbd5-ea9c-44b8-8403-65ac070cf811.webp)



 面向对象的继承 

 原型继承 

子类原型指向父类的实例

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641994558926-4ce6bb4c-7f02-4137-8a8b-abc199fc381a.webp)



原型继承的原理

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641996836131-90796ef6-56e3-4872-b41c-4f5c3731bf0e.webp)



原型继承缺点:

1、子类可以修改父类原型上的方法

2、父类中私有或公有的属性方法，最后都会变成子类中公有的属性和方法



 call继承 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641995831157-a25b5b4e-56ff-4eaf-8190-a8a4055e115f.webp)



 寄生组合继承 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641996107694-671106c8-4328-4961-8774-f8adf743d31e.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641997817753-f85b36f8-f8ec-4c73-95f3-611e1fd6c70e.webp)



 ES6继承 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641998830852-cec68bfa-4751-4f5e-b442-b4bd8d75e950.webp)



 





