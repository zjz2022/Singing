**1 npm**

npm是围绕着[语义版本控制（semver）](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Fsemver.org%2F)的思想而设计的，下面是从他们的网站摘抄过来的：

*给定一个版本号：主版本号.次版本号.补丁版本号， 以下这三种情况需要增加相应的版本号:*

- *主版本号： 当API发生改变，并与之前的版本不兼容的时候*
- *次版本号： 当增加了功能，但是向后兼容的时候*
- *补丁版本号： 当做了向后兼容的缺陷修复的时候*

npm 2会安装每一个包所依赖的所有依赖项。如果我们有这么一个项目，它依赖项目A，项目A依赖项目B，项目B依赖项目C，将会构建为一棵树；npm 3采用了扁平依赖关系树来解决这个问题，

```
node_modules
- package-A
- package-B
- package-C
-- some-file-name-in-package-c.js
```

这种方法的缺点是，npm必须首先遍历所有的项目依赖关系，然后再决定如何生成扁平的node_modules目录结构。npm必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，导致 npm 速度很慢。

**2 yarn**

Yarn一开始的主要目标是解决上一节中描述的由于语义版本控制而导致的npm安装的不确定性问题。虽然可以使用npm shrinkwrap来实现可预测的依赖关系树，但它并不是默认选项，而是取决于所有的开发人员知道并且启用这个选项。

Yarn采取了不同的做法。每个yarn安装都会生成一个类似于npm-shrinkwrap.json的yarn.lock文件，而且它是默认创建的。除了常规信息之外，yarn.lock文件还包含要安装的内容的校验和，以确保使用的库的版本相同。

**3 pnpm**

- npm会将依赖包安装到`node_modules`中。
- pnpm将依赖包安装到`.pnpm`中。

​		与npm的依赖提升和扁平化不同。pnpm采取了一套新的策略：**内容寻址储存**；pnpm拥有自己的.pnpm目录，他会以平铺的方式来存储所有包，以依赖名加上版本号的名字为命名，实现了版本的复用。而且他不是通过拷贝机器缓存中的依赖到项目目录下，而是通过硬链接的方式，这能减少空间占用。至于根目录下用于项目使用的依赖，则是通过符号链接的方式，链接到它的 .pnpm 目录下的对应位置。

1. **存储结构**：

- npm为每个依赖包创建一个软链接指向`node_modules`，存在大量软链接使存储占用大。
- pnpm使用硬链接将依赖包链接到项目中，这样可以减少存储占用和安装时间。

1. **安装速度**：

- npm每个项目都需要安装和下载依赖包，速度较慢。
- pnpm使用硬链接，相同的依赖包可以被多个项目共享，能够更快地安装依赖包。

1. **兼容性**：

- npm是默认的JavaScript包管理器，广泛使用于大多数项目。
- pnpm是新兴的包管理工具，可以与npm兼容，并与多个npm生态系统工具协同工作，但可能存在与一些npm插件和工具的不兼容问题。