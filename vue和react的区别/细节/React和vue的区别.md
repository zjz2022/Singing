https://github.com/pro-collection/interview-question/issues/83

## React和vue的区别

1）相同点

- 都有组件化思想
- 都支持服务器端渲染
- 都有Virtual DOM（虚拟dom）
- 数据驱动视图
- 都有支持native的方案：Vue的weex、React的React native
- 都有自己的构建工具：Vue的vue-cli、React的Create React App

2）区别

```
写在前面：

前端选型无非是考虑包体积和响应速度两种，目前的前端框架都需要编译这一步骤，分为构建时编译（AOT），宿主环境执行时编译（JIT）【区别：JIT首次加载慢于AOT，因为需要先编译，且体积可能大于AOT，因为运行时会增加编译器代码】，Angular提供了两种方式但是没人用。

借助AOT对模板语法编译时的优化，比如vue3由于模板是固定的，因此在编译时可以分析模板语法中的静态部分和动态部分做出优化，Svelte可以利用AOT直接建立这部分的关系，在运行时当自变量发生变化直接驱动UI变化，但是JSX很灵活导致很难进行静态分析。【react采用prepack进行过改进，但2019年放弃了。也尝试过使用forget自动生成等效于memo等的代码的编译器，但使用模板减少了jsx的灵活性，也有人使用millionJS直接将元素绑定在dom上等】。

既然jsx无法实现AOT，那么就采用了vDom进行优化，并把memo等缓存交给程序员进行work。

前端框架分为元素级（svelte），组件级（vue），应用级（react），对于svelte来说，由于可以确定自变量是否变化，如果组件没有使用store则不会引入这一特性，会使得其对于小型应用比react的体积小，对于大型应用由于元素级直接绑定dom导致体积逐渐增大。vue采用模板语法，建立自变量与组件之间的关系，因此可以受益于AOT。react每次从应用的根节点开始遍历，甚至不知道哪个自变量变了就开始更新，导致不需要细粒度更新和AOT，当然也采用了调度，时间切片等进行优化。

框架性能瓶颈：

**react：**

高频率的交互往往会导致明显的性能问题，在 antd 的 Form 组件也使用了将数据下放到每一个 Item 的方式来优化性能，store 中用 useRef 存储数据而不是 useState，antd 内部为每个 Form.Item 定义了 forceUpdate 来强制更新 Item UI。又例如拖拽/resize等事件。此时我们只需要通过操作原生 DOM 的方式来实现对应的逻辑即可。从而绕开高频率的 diff 逻辑。

react 常常因为闭包问题，被各种攻击。认为这是 react 的缺陷。

事实上，原生 DOM 本身在高频交互上也存在明显的性能瓶颈。因此许多前端项目不得不采用抛弃 DOM 渲染的方式来完成整个项目【DOM 换成了 canvas，或者 webGPU..】。但是这些项目我们仍然可以结合 react 来完成，例如著名的前端项目 **Figma**，或者国内有的团队使用 react + skia 的方式来完成一些对性能要求很高的项目

**Solid：**

 为了极致的性能体验，完全弃用了虚拟 DOM，也就意味着，他放弃了跨平台的特性。只把主要精力集中在 web 项目上。也就是说，他的全局生态建设，永远也赶不上 react。

**vue：**

丢失响应式，如解构。
```

- 数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流

```
在双向绑定的建立过程中，有一个理想的结果：我们可以轻易的知道数据与 DOM 节点的对应关系，那么通过数据驱动 UI 的形式来开发代码将会变得非常容易。双向绑定采取的措施是递归遍历监听所有数据，依次建立与对应 UI 的绑定关系。这种解决方案所花费的成本主要体现在对数据的处理上，他面临两个问题：
一是数据的变化需要监听，但是某些数据类型的监听在实现上有难度，比如 forceUpdate，比如大量的 Watcher，还有性能损耗更严重的 Deep Watcher。另一个问题就是数据的层级与变化问题，数据层级越深，我们想要深度监听，就得使用递归的方式。当数据发生变化时，部分数据与 UI 的绑定关系需要重新建立「在 vue 中，就是重复依赖收集的过程」，如果数据量过大，或者数据变化频繁，就会有性能风险。
react 把所有的精力都放在了 UI 层。使用我们现在熟知的 diff 算法，当数据发生变化时，react 会创建一个新的虚拟DOM树，与之前的树做对比，找出需要改变的元素。
从总体思路上来说，vue 的主要压力在于处理数据，react 的主要压力在于处理 UI。react 不建立数据与 UI 的对应关系，那么也就意味着另外一个压力的产生，那就是当数据发生变化时，react 并不知道哪一个 UI 发生了变化，于此同时 react 为了保持自己对于 Js 的弱侵入性，也没有在 setState 上进行任何魔改，例如绑定当前上下文从而得知具体哪个组件的 state 发生了变化。[如果进行了这个魔改，diff 的压力会小一些]。因此，每一次的 state 变化，都是整棵 DOM 树的 diff。
Vue2中借鉴了diff算法，vue3中使用Proxy 能够监听数组的变化，能够监听删除对象字段的变化... 于是 Vue3 的底层实现，在数据侧的代码会简洁很多，并且与此同时，Vue 的后续版本，也可以彻底放弃虚拟 DOM 来进一步提高自己的运行性能。但是，依然有一个问题没有解决，那就是深度监听仍然需要递归。当数据量很大的时候，依赖追踪的压力也会逐渐变大，当你的项目变得越来越大，全局数据变得越来越复杂，层级越来越深，他的性能压力也会逐渐变大。因此这也是目前大多数大厂中后台采用React的原因，而面向用户则采用Vue的原因。
```

- 数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据

```
Vue2 响应式的特点就是依赖收集，数据可变，自动派发更新，初始化时通过 Object.defineProperty 递归劫持 data 所有属性添加 getter/setter，触发 getter 的时候进行依赖收集，修改时触发 setter 自动派发更新找到引用组件重新渲染。
Vue3 响应式使用原生 Proxy 重构了响应式，一是 proxy 不存在 Vue2响应式存在的缺陷，二是性能更好，不仅支持更多的数据结构，而且不再一开始递归劫持对象属性，而是代理第一层对象本身。运行时才递归，用到才代理，用 effect 副作用来代替 Vue2 里的 watcher，用一个依赖管理中心 trackMap 来统一管理依赖代替 Vue2 中的 Dep，这样也不需要维护特别多的依赖关系，性能上取得很大进步。
React 则是基于状态，单向数据流，数据不可变（需要创建数据的副本来替换掉原数据，为了保证浅比较的正确性），需要手动 setState 来更新，始终保持state的原值不变,在生命周期 shouldComponentUpdate 中，React会对新旧state进行比较，如果直接修改state去用于其他变量的计算，而实际上state并不需要修改，则会导致怪异的更新以及没必要的更新。第二，可追踪修改痕迹，便于排错。而且当数据改变时会以组件根为目录，默认全部重新渲染整个组件树，只能额外用 pureComponent/shouldComponentUpdate/useMemo/useCallback 等方法来进行控制，更新粒度更大一些。
```

- 组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数
- diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM

```
Vue2 是同层比较新老 vnode，新的不存在老的存在就删除，新的存在老的不存在就创建，子节点采用双指针头对尾两端对比的方式，全量diff，然后移动节点时通过 splice 进行数组操作
Vue3 是采用 Map 数据结构以及动静结合的方式，在编译阶段提前标记静态节点，Diff 过程中直接跳过有静态标记的节点，并且子节点对比会使用一个 source 数组来记录节点位置及最长递增子序列算法优化了对比流程，快速 Diff，需要处理的边际条件会更少
React 是递归同层比较，标识差异点保存到 Diff 队列保存，得到 patch 树，再统一操作批量更新 DOM。Diff 总共就是移动、删除、增加三个操作，如果结构发生改变就直接卸载重新创建，如果没有则将节点在新集合中的位置和老集合中的 lastIndex 进行比较是否需要移动，如果遍历过程中发现新集合没有，但老集合有就删除
```

- vue3 做了自己的一套编译优化处理方式。

3）其他

- React的核心理念是用一个hooks解决所有问题，vue的理念是解决不了就新增api

React一直在淡化hooks（useEffect）和生命周期的联系，甚至淡化其与组件的关系。 如在严格模式下，dev环境会触发多次useEffect的回调，目的是想让开发者将useEffect看做针对某个数据源的同步过程。

【如果react支持keepalive，从生命周期的角度理解，effect回调应该执行，从状态角度理解不应该执行】

react的更新策略是掌握在开发者自己手中的，可以主动开启并发更新，对更新做结果优化缓存优化及渲染优化；vue是自动收集依赖的精准更新，没有并发更新特性