## SSR、CSR、SSG、SEO

**SEO：**

SEO就是指按照搜索引擎的算法，提升文章在搜索引擎中的自然排名。

SSR利于SEO，因为不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本（Google除外，据说Googlebot可以运行javaScript）。使用了React或者其它MVVM框架之后，页面大多数DOM元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取我们的页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。

**SPA：**

​		单页 Web 应用（single page web application，SPA），就是只有一张 Web 页面的应用，是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序		简单说： Web 不再是一张张页面，而是一个整体的应用，一个由路由系统、数据系统、页面（组件）系统…组成的应用程序，其中路由系统是非必须的。		大部分的 Vue 项目，本质是 SPA 应用，Angular.js、Angular、Vue、React…还有最早的”Pjax”均如此。SPA 时代，主要是在Web端使用了history或hash（主要是为了低版本浏览器的兼容）API，在首次请求经服务端路由输出整个应用程序后，接下来的路由都由前端掌控了，前端通过路由作为中心枢纽控制一系列页面（组件）的渲染加载和数据交互。而上面所述的各类框架则是将以：路由、数据、视图为基本结构进行的规范化的封装。		最早的 SPA 应用，由 Gmail、Google Docs、Twitter 等大厂产品实践布道，广泛用于对SEO要求不高的场景中。		优点：客户端渲染、数据传输量小、减少服务器端压力、交互/响应速度快、前后端完全分离；		缺点：首屏加载慢、对SEO不友好，不利于百度，360等搜索引擎收录快照；

**MPA:**

MPA(multipage application): 多页面应用，即一个web项目就有多个页面（即多个HTML文件）。指有多个独立页面的应用（多个html页面），每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。

| 组成              | 一个外壳页面和多个页面片段组成                               | 多个完整页面构成                                          |
| ----------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| 资源共用(css,js)  | 共用，只需在外壳部分加载                                     | 不共用，每个页面都需要加载                                |
| 刷新方式          | 页面局部刷新或更改                                           | 整页刷新                                                  |
| url 模式          | a.com/#/pageone    a.com/#/pagetwo                           | a.com/pageone.html a.com/pagetwo.html                     |
| 用户体验          | 页面片段间的切换快，用户体验良好 由于要一次加载所有的资源(html/js)，故首屏加载慢 | 页面切换加载缓慢，流畅度不够，用户体验比较差 首屏加载很快 |
| 转场动画          | 容易实现                                                     | 无法实现                                                  |
| 数据传递          | 容易实现                                                     | 依赖 url传参、或者cookie 、localStorage等                 |
| 搜索引擎优化(SEO) | 需要单独方案、实现较为困难、不利于SEO检索。                  | 实现方法简易                                              |
| 试用范围          | 高要求的体验度、追求界面流畅的应用                           | 适用于追求高度支持搜索引擎的应用                          |
| 开发成本          | 较高，常需借助专业的框架                                     | 较低，但页面重复代码多                                    |
| 维护成本          | 相对容易                                                     | 相对复杂                                                  |

```
1.在vue.config.js中的 multi-page 模式下构建应用。每个“page”应该有一个对应的 JavaScript 入口文件。其值应该是一个对象，对象的 key 是入口的名字，value 是：entry(main.js), template(index.html), filename(在 dist/ index. html 的输出), title 和 chunks 的对象。
2.统一配置多页，遍历每一个pages
3.修改title，html模版中的title使用模版语法
4.合并第三方库，如果不设置分包,所有node_modules资源都被打包进chunk-vendors
在配置了多页应用时，就不能配置publicPath为./了！（相对路径）否则无法访问到其它页面。
```

https://juejin.cn/post/7054439846927925256

https://juejin.cn/post/7113757268520206350

**SSR：**

​		服务端渲染（Server Side Render）是指一种传统的渲染方式，就是在浏览器请求页面URL的时候，服务端将我们需要的HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中。

​		优点：对于SEO友好、首屏加载速度快；

​		缺点：页面重复加载次数高、开发效率低、数据传输量大、服务器压力大；

为什么可以做性能优化：

1、对服务器提出更高的要求，生成虚拟DOM如果相对较长的运行和计算耗时；

2、由于cgi拉取和vdom直出后才吐出HTML页面，FMP虽然提前了，但是FP相对延迟了；

3、相比CSR，SSR渲染后，由于仍然需要进行依赖、vue初始化，页面可交互时间并没有较大改善。

缓存优化：

1、页面级别缓存：vuessr官网给我们提供了一种方法，如果页面并非千人千面，总是为所有用户渲染相同的内容，我们可以利用名为 micro-caching 的缓存策略，来大幅度提高应用程序处理高流量的能力。这通常在 Nginx 层完成，也可以在 Node.js 中实现。

2、组件级别缓存：通过对组件设置serverCacheKey的方式，如果组件serverCacheKey相同，将复用之前渲染的组件产物，不需要重新渲染。

3、减少组件嵌套层次，优化HTML结构：由于组件最初需要在node后端进行VDOM计算和渲染，优化组件层次结构，减少过深曾经的DOM嵌套，可以减少VDOM计算耗时。

4、减少首页渲染数据量：根据业务调整用户首屏可见的所需渲染的数据，其他数据懒加载或异步加载。

5、流式传输：vuessr官网给我们介绍了一种方法，render对象会暴露renderToStream方法，把原有的直出结果以流的形式输出，让我们可以更快的响应数据到客户端，能减少首屏渲染时间，更早开始加载页面资源。（流式传输需要在asyncData执行结束后开始，否则没有数据，这意味着流失传输受限于cgi拉取耗时）

6、分块传输：lucien大佬在tweb大会上给我们带来了新的思路，由模板的语法树， 分析代码的上下文，分析数据和模板间的依赖，用异步数据分割模板，分块逐步输出。（相比流式传输，前置位的cgi数据一旦ready，就会渲染输出，而不需要等待所有的gi拉取到后才开始渲染输出，但是该方案改造成本较大）

7、改造直出算法，不用vue-loader而用自研的aga-loader，将vdom渲染转换为字符串模板，具有更高的渲染性能。

**CSR:**

​		CSR全称是 Client Side Rendering ，代表的是客户端渲染。顾名思义，就是在渲染工作在客户端（浏览器）进行，而不是在服务器端进行。举个例子，我们平时用vue，react等框架开发的项目，都是先下载html文档（不是最终的完全的html），然后下载js来执行渲染出页面结果。

CSR的优势：

前后端分离，前端专注于 UI，服务端专注于逻辑。可以实现局部刷新，无需每次都请求完整页面，用户体验好。给服务器减负，部署简单。交互性好，方便实现各种效果。

CSR的局限：

不利于SEO，爬虫难以爬取内容。首屏渲染慢，渲染前需要加载一堆 js 和 css 文件。客户端负担重。

**SSG:**

​		静态站点生成 (Static-Site Generation，缩写为 SSG)，也被称为预渲染，是另一种流行的构建快速网站的技术。如果用服务端渲染一个页面所需的数据对每个用户来说都是相同的，那么我们可以只渲染一次，提前在构建过程中完成，而不是每次请求进来都重新渲染页面。预渲染的页面生成后作为静态 HTML 文件被服务器托管。SSG ，代表的是静态站点生成。在构建的时候直接把结果页面输出html到磁盘，每次访问直接把html返回给客户端，相当于一个静态资源。

​		SSG 保留了和 SSR 应用相同的性能表现：它带来了优秀的首屏加载性能。同时，它比 SSR 应用的花销更小，也更容易部署，因为它输出的是静态 HTML 和资源文件。这里的关键词是静态：SSG 仅可以用于消费静态数据的页面，即数据在构建期间就是已知的，并且在多次部署期间不会改变。每当数据变化时，都需要重新部署。

​		如果你调研 SSR 只是为了优化为数不多的营销页面的 SEO (例如 /、/about 和 /contact 等)，那么你可能需要 SSG 而不是 SSR。