## Http发展

| 0.9  | html文件传输           | 确定了客户端请求，服务器响应的通信流程 |
| ---- | ---------------------- | -------------------------------------- |
| 1.0  | 不同类型文件传输       | 设立头部字段                           |
| 1.1  | 创建/断开TCP连接开销大 | 建立长连接进行复用                     |
| 2    | 并发数有限             | 二进制分帧                             |
| 3    | TCP丢包阻塞            | 采用UDP协议                            |

**对头阻塞：**

​		头部阻塞是 TCP中的一个问题，当一个 TCP 流中的一个数据包丢失时，整个流都会被阻塞，直到丢失的数据包被重新发送和接收。HTTP/1.1 时代建立一个 TCP 连接，三个请求组成一个队列发出去，服务器接收到这个队列之后会依次响应，一旦前面的请求阻塞，后面的请求就会无法响应。

​		HTTP/2 并没有解决 TCP 的队首阻塞问题，它仅仅是通过**多路复用**解决了以前 HTTP1.1 **管线化**请求时的队首阻塞。HTTP/2 是通过**分帧**并且给每个帧打上**流**的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题。但是 TCP 层面的队首阻塞是 HTTP/2 无法解决的（HTTP 只是应用层协议，TCP 是传输层协议），TCP 的阻塞问题是因为传输阶段可能会丢包，一旦丢包就会等待重新发包，阻塞后续传输，这个问题虽然有**滑动窗口（Sliding Window）**这个方案，但是只能增强抗干扰，并没有彻底解决。

​		HTTP/3 通过使用基于 UDP 的 QUIC 协议来解决这个问题。在 QUIC 中，流是独立的，如果一个流中的数据包丢失，它不会影响其他的流。这就意味着，即使在一个流中发生了数据包丢失，其他的流仍然可以继续传输数据。这样就消除了头部阻塞问题。

**长连接与管道：**

​		在 HTTP/0.9 版本中，HTTP 请求是以短连接进行的，因此在发送完 HTTP 的响应之后，服务器就会断开 TCP 连接。可是这样是一件很耗资源、很耗时间的事情，所以在 1.0 版本中，新增了 keep-alive 字段，让长连接被 HTTP 支持了（此时默认还是不会开启长连接）。所谓长连接，就是完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。好处是连接可以被重新使用，之后发送 HTTP 请求的时候就不需要重新建立 TCP 连接了，以及如果维持连接，那么 SSL 的开销也可以避免。

好处如此之多，所以 HTTP/1.1 就把 Connection: keep-alive 头写进了标准，并且默认开启持久连接(两小时，心跳检测 5次)。

必须在请求中声明：Connection: close 才会让每次 HTTP 请求都重新建立 TCP 连接。

- 如果是「短连接」，那么一次 TCP 连接就只能对应一次 HTTP 请求；
- 如果是「长连接」，那么一次 TCP 连接就可以发送多个 HTTP 请求了。

管道是 HTTP/1.1 规范中的字段，能将多个 HTTP 请求整批提交，在发送过程中不需先等待服务器的回应。因为该技术存在很多问题：

1. 一些代理服务器不能正确的处理 HTTP Pipelining；
2. 正确的流水线实现是复杂的；
3. Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。

HTTP2 提供了 Multiplexing 多路传输特性，让我们可以在一个 TCP 连接中同时完成多个 HTTP 请求。（可以将数据拆成包，给每个包打上标签。到了服务器在进行拼接即可，本质上还是管道）

连接上限：

​		浏览器允许我们对同一 host 开启多个 TCP 连接，每个浏览器的数量是不一样的。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。

​	**Http和Https的区别：**

​		HTTP协议也就是超文本传输协议，是一种使用明文数据传输的网络协议。一直以来HTTP协议都是最主流的网页协议，HTTP协议被用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。

​		为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。HTTPS协议可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息仍然是安全的。

​		具体过程为：客户端发起 SSL orTLS握手 -> 服务端将证书发送给客户端 -> 客户端检查是否为 CA （双方约定可信任证书签发机构）-> 服务端检查客户端 CA 证书 ；

**Http2和Http3区别：**

​		HTTP2协议虽然大幅提升了HTTP/1.1的性能，然而，基于TCP实现的HTTP2遗留下3个问题：

- 有序字节流引出的队头阻塞（Head-of-line blocking），使得HTTP2的多路复用能力大打折扣；
- TCP与TLS叠加了握手时延，建链时长还有1倍的下降空间；
- 基于TCP四元组确定一个连接，这种诞生于有线网络的设计，并不适合移动状态下的无线网络，这意味着IP地址的频繁变动会导致TCP连接、TLS会话反复握手，成本高昂。

​		HTTP3协议解决了这些问题：

- HTTP3基于UDP协议重新定义了连接，在QUIC层实现了无序、并发字节流的传输，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）；
- HTTP3重新定义了TLS协议加密QUIC头部的方式，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个RTT就可以同时完成建链与密钥协商）；
- HTTP3 将Packet、QUIC Frame、HTTP3 Frame分离，实现了连接迁移功能，降低了5G环境下高速移动设备的连接维护成本。

**Https发展**

背景：早期的数据在网络传输中使用的http协议，这种协议采取的是明文传输的方式。从一个结点到另一个结点传输的过程中会存在一些不法分子从中窃取信息。早起的运营商也会利用职务之便进行数据劫持，在web里插入代码显示广告。在20世纪90年代中期，当人们意识到互联网应用越来越广泛，所传递的信息价值越来越高时，便不得不考虑对网络进行安全性处理。最早吃螃蟹的是当时最大的网景公司，在1994年对**http1.1**进行了升级。https发展:最早采用的方法便是加密，加密和解密采用相同的密钥，如凯撒加密，恩格码机等，这种加密方式就是对称加密。但是要想让传输双方进行解密，那在传递的过程中需要把密钥一起传递，这种加密方式就失去了意义。于是产生了非对称加密，利用公钥和私钥。服务器先将自己的公钥发送给浏览器。浏览器生成一个随机的数据，用服务器的公钥加密然后发送给服务器，服务器利用自己的私钥进行解密，于是就产生了一份相同的数据。这份数据用作双方传递的密钥进行加密传输。这是一套独立于http协议的流程，被称为安全套接字层（secure socket layer-ssl）后来ssl进行了三次升级，最后一次升级后被冠以TSL进行正式发布。所以TSL1.0也被叫做ssl3.1。升级过程是对加密方式的升级，比如舍弃了md5采用sha-256。但是如果有人将服务器传递给浏览器的公钥进行窃取然后更换成自己的公钥发送给浏览器，依旧会存在安全性问题。因此引入了CA的概念，ca会进行第三方加密以验证服务器身份，这就是TsL证书。这些ca机构会被保存在客户端本地以供浏览器需要。前几年有些网站自己给自己颁发证书，会存在不被认可的问题，12306。但是ca机构的权利过于集中，一旦ca机构出现问题，导致的问题不可估量。比如google和赛门铁克，还有棱镜门利用虚假的证书来窃听用户隐私。因此，引入了证书透明化，ct。但是这种套娃的操作并不能很好的解决该类问题。因此我认为去中心化才是核心。区块链给人们最大的启示就是任何中心化的技术都是不被信任的，无论他如何权威。ct中的日志服务采用了区块链中的默克尔树进行防篡改实现。这是一种类似于归并去计算每一层hash的方法，将根hash保存在每一个客户端上。

**HTTPS 握手过程中，客户端如何验证证书的合法性**

```
校验证书的颁发机构是否受客户端信任。
2. 通过 CRL 或 OCSP 的方式校验证书是否被吊销。
3. 对比系统时间，校验证书是否在有效期内。
4. 通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。
证书包含：公钥、公钥拥有者名称、CA的数字签名、有效期、授权中心名称、证书序列号等信息。
```

**怎么通过数字证书验证服务器身份**

1. 客户端发起连接请求：客户端向服务器发起连接请求，例如使用HTTPS协议访问一个网站。

ssl握手过程中，浏览器会通过证书链层层验证，直至操作系统上的根证书，根证书存储在客户端本地【`C:\Windows\System32`】，其余的存储在服务器上。

1. 服务器发送数字证书：服务器将其数字证书发送给客户端。数字证书是由可信任的证书颁发机构（CA）颁发的，其中包含了服务器的公钥以及其他相关信息。
2. 客户端验证数字证书的合法性：客户端会使用内置的根证书颁发机构列表（或者操作系统提供的信任存储）来验证服务器发送的数字证书的合法性。客户端会检查证书的签名是否有效、证书是否过期、证书是否被吊销等。

以下三步：向服务器发送一个随机数，从证书中获取服务器端的公钥，对随机数加密；编码改变通知，表示随后信息都将使用双方协定的加密方法和密钥发送；客户端握手结束通知。

1. 公钥提取：如果数字证书通过验证，客户端会从证书中提取出服务器的公钥。
2. 生成随机密钥：客户端会生成一个随机的对称密钥，用于加密通信过程中的数据。
3. 使用服务器的公钥加密对称密钥：客户端使用服务器的公钥对随机生成的对称密钥进行加密，然后将加密后的对称密钥发送给服务器。

服务器端对数据解密得到随机数，发送消息：编码改变通知，表示随后信息都将使用双方协定的加密方法和密钥发送。

1. 服务器使用私钥解密对称密钥：服务器使用自己的私钥解密收到的加密对称密钥。
2. 建立加密通道：客户端和服务器双方现在都拥有相同的对称密钥，它们可以使用该密钥来进行加密和解密通信内容，建立安全的加密通道。

​	**SSL和TLS区别：**

SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。

TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。

SSL协议提供的服务主要有：

1）认证用户和服务器，确保数据发送到正确的客户机和服务器；

2）加密数据以防止数据中途被窃取；

3）维护数据的完整性，确保数据在传输过程中不被改变。

TLS 记录协议提供的连接安全性具有两个基本特性：

​		私有――对称加密用以数据加密（DES 、RC4 等）。对称加密所产生的密钥对每个连接都是唯一的，且此密钥基于另一个协议（如握手协议）协商。记录协议也可以不加密使用。



​		可靠――信息传输包括使用密钥的MAC进行信息完整性检查。安全哈希功能（ SHA、MD5 等）用于 MAC 计算。记录协议在没有 MAC 的情况下也能操作，但一般只能用于这种模式，即有另一个协议正在使用记录协议传输协商安全参数。

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/v2-0a145c61756af47c470679edd400d390_720w.webp)

参考：

- HTTP发展史，HTTP1.1与HTTP2.0的区别  https://juejin.cn/post/7079936383925616653
- https://www.cnblogs.com/xhyccc/p/14392670.html
- https://segmentfault.com/q/1010000005167289