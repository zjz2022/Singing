#### 进程与线程

进程是操作系统进行资源分配的基本单位，每个进程都有自己的独立内存空间。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

线程又叫做轻量级进程，是进程的一个实体，是处理器任务调度和执行的基本单位位。它是比进程更小的能独立运行的基本单位。线程只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

对于操作系统来说，一个任务就是一个进程（Process）。比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个 Word 就启动了一个 Word 进程。

有些进程还不止同时干一件事，比如 Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，进程内的这些“子任务”称为线程（Thread）。

由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像 Word 这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。

#### 协程

协程，又称微线程，是一种用户态的轻量级线程，协程的调度完全由用户控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到线程的堆区，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和线程切换相比，线程数量越多，协程的性能优势就越明显。不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。此外，一个线程的内存在 MB 级别，而协程只需要 KB 级别。

![1713796646392](image/协程怎么实现的，这些本质上有什么区别？/1713796646392.png)

#### 进程和线程的区别

每个线程都是一个轻量级进程(Light Weight Process)，都有自己的唯一 PID 和一个 TGID(Thread group ID)。TGID 是启动整个进程的 thread 的 PID。

例如，当一个进程被创建的时候，它其实是一个 PID 和 TGID 数值相同线程。当线程 A 启动线程 B 时，线程 B 会有自己的唯一 PID，但它的 TGID 会从 A 继承而来。这样通过 PID 线程可以独立得到调度，而相同的 TGID 可以知道哪些线程属于同一个进程，这样可以共享资源(RAM，虚拟内存、文件等)。

线程进程的区别体现在 6 个方面：

- 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。
- 资源开销：每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一进程的线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
- 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。
- 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。
- 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
- 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。两者均可并发执行。

#### 协程与线程的区别

1. 一个线程可以有多个协程。
2. 大多数业务场景下，线程进程可以看做是同步机制，而协程则是异步。
3. 线程是抢占式，而协程是非抢占式的，所以需要用户代码释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。
4. 协程并不是取代线程，而且抽象于线程之上。线程是被分割的 CPU 资源, 协程是组织好的代码流程, 协程需要线程来承载运行。

### 进程间的通信方式(IPC)

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）

### 线程间的通信方式

#### 锁(Lock)

锁机制包括互斥锁、条件变量、读写锁。

1. 互斥锁提供了以排他方式防止**数据结构**被并发修改的方法。
2. 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
3. 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

> 有关**Java**的锁机制，可以点击查看《[详解 Java 多线程锁之 synchronized](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUyNzgyNzAwNg%3D%3D%26mid%3D2247483792%26idx%3D1%26sn%3D5f4a1763876bdc03aad3fdfbdc1f1779%26scene%3D21%23wechat_redirect&source=article&objectId=1839604)》和《[详解 Java 多线程锁之 Lock 和 ReadWriteLock](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUyNzgyNzAwNg%3D%3D%26mid%3D2247483798%26idx%3D1%26sn%3Dcceca939e36c1b1748b290dc34d1f4cc%26scene%3D21%23wechat_redirect&source=article&objectId=1839604)》
>
> 有关条件变量，可以点击查看《[Java 多线程的可见性与有序性](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUyNzgyNzAwNg%3D%3D%26mid%3D2247483819%26idx%3D1%26sn%3D2b8a7b636f870b29df3c0c98be5eca82%26scene%3D21%23wechat_redirect&source=article&objectId=1839604)》中有关 volatile 的讲解。

#### 信号量(Semaphore)

可以查看这篇博客《[快速了解基于 AQS 实现的 Java 并发工具类](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUyNzgyNzAwNg%3D%3D%26mid%3D2247483885%26idx%3D1%26sn%3D8fe2bf133cbc7932def11e407e76a783%26scene%3D21%23wechat_redirect&source=article&objectId=1839604)》中有关 Semaphore 的讲解，感受下信号量如何在 java 线程通信中的使用。

#### 信号(Signal)

可以查看这篇博客：《[彻底搞懂 Java 的等待-通知(wait-notify)机制](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUyNzgyNzAwNg%3D%3D%26mid%3D2247483954%26idx%3D1%26sn%3Dcc77f94e46cf5351b28da91eda01ec2b%26scene%3D21%23wechat_redirect&source=article&objectId=1839604)》

### 协程间的通信方式

与线程不同，协程使用程序自定义的调度器进行调度，因此更容易控制协程之间的执行顺序，要想充分利用协程的调度模型，有一个完备的通信机制是很重要的。它主要应该有以下的功能：

1. 能从一个协程发送消息到另一个协程，通知另一个协程特定的事件已经发生。
2. 能够让协程在事件未发生之前挂起，等待事件发生后被调度并处理，从而有效让出 CPU 时间。
3. 能够在消息中附带相应的数据。
