# 函数 

函数是一个方法或一个功能体，函数就是把实现某个功能的代码放到一起进行分装，以后想要操作这个功能把函数执行就可以



提高代码重复使用率(低耦合高内聚)

### 创建函数

function [函数名](形参1，形参2){

​    函数体

​    return  [处理后的结果]

}



[函数名]()



创建函数时设置了形参变量，但执行的时候没有传递对应的实参，那么形参变量默认的值是undefined，

函数体内部创建的变量是无法获取和操作的，如果想要获取内部的信息，我们需要基于return返回机制，把信息返回才可以

函数体重遇到return，后面代码就不会再执行了



 #### 返回值

1、返回一个值，拿变量接收

2、想用函数内部变量需要有返回值

3、return的作用可能只是不想让后面代码继续执行

4、没返回值默认返回undefined



### 匿名函数

把一个匿名函数本身作为值赋值给其他东西，这种函数一般不是手动触发执行的，而且靠其他程序驱动触发执行(例如:触发某个时间的时候把他执行)



### 函数底层运行机制

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640663695472-1d7df685-2003-4c9e-9084-e2c8b69b0dcf.webp)





### arguments函数的实参集合

1、类数组集合，集合中存储这所有函数执行时，传递的实参信息





### 箭头函数

 this 

函数执行的主体(不是上下文):意思就是谁把函数执行的，那么执行主体就是谁

1、给元素的某个事件绑定方法，当事件触发方法执行的时候，方法中的this是当前操作的元素本身

2、自执行函数的this是window或undefined

3、如何确定执行主体(this)是谁，当方法执行的时候，我们看方法前面是否有点，没有点this是window或undefined，有点前面是谁就是谁

this判断

1、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640923289552-d60e92f4-b83f-4569-99b9-f67bed59f4ef.webp)



2、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640923300285-91f778ed-cc28-4d94-a4fd-9874123d0eb7.webp)



3、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640923482547-429d2d26-a17a-4ba5-8c52-bbe3c5314b22.webp)



 闭包作用域 

### 创建函数 

   开辟一个堆内存

   把函数体的代码当做字符串存储进去

   把堆内存的地址赋值给函数名/变量名

   函数在哪创建，那么它执行时候所需查找的上级作用域就是谁

#### 函数执行

   形成一个全选的私有作用域、执行上下文、私有栈内存(执行一次形成一个，多个之间不会产生影响)

#### 形参赋值&变量提升

   代码执行(把所属堆内存中的代码字符串拿出来一行行执行)

   遇到一个变量首先看他是否是私有变量(形参和在私有作用域中声明的变量是私有变量)，是私有的就操作自己的变量即可，不是私有的则向上级作用域中查找...一直找到全局作用域为止=>作用域链查找机制

   私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来，这种机制其实就是闭包的保护机制

### 关于堆栈内存释放问题(以谷歌浏览器为主)

函数执行就会形成栈内存(从内存中分配的一块空间),如果内存都不销毁释放，就很容易会导致栈内存溢出(内存爆满，电脑就卡死了)，堆栈内存的释放问题就是学习js的核心知识

### 堆内存释放问题

//=>创建一个引用类型值就会产生一个堆内存

如果当前创建的堆内存不被其他东西所占用，浏览器会在空闲的时候查找每一个内存的引用状况，不被占用的都会自己回收掉

### 栈内存释放

//=>打开浏览器形成的全局作用域

//=>手动执行函数形成的私有作用域

//=>基于ES6的let/const形成的块作用域是栈内存



1、一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁释放掉(排出出现无限递归，出现死循环的模式)

2、一旦栈内存中的某个东西(一般都是堆地址)被私有作用域以外的事物给占用了,则当前私有栈内存不能立即被释放销毁



闭包:函数执行形成不能被释放的私有栈内存，这样的才是闭包



 闭包的作用: 

1、保护(私有变量和外界没有必然联系)

2、保存(形成不销毁的栈内存，里面私有信息被保存下来了)

3、防止全局变量污染问题(jq)

jq里面有很多方法，如果这时候一个程序员声明了一个方法比如prevAll，和jq里提供的方法重名了，这时候会存在覆盖吗？

答案是不会，因为为了防止全局变量污染(解释:导入JQ后,里面有大量的方法，如果这些方法不保护起来很容易和用户编写的方法产生冲突，这就是全局变量污染，为了防止这种污染，jq中的方法需要用闭包保存起来)

4、从性能角度讲，真实项目中应该减少对闭包的使用(因为闭包会产生不释放的栈内存，过多使用容易导致内存溢出或者性能降低)

jq中闭包用处

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640921292249-54b5132b-e059-48f5-8d75-04f5036521c3.webp)



### 真实项目中

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640921273247-3c7ce39e-9996-4915-b250-582c814000c7.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640921239898-2fc8c5c0-d49b-45d4-8db9-773c9c8cd2d3.webp)



 函数的三种角色 

 练习题 

### 一、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640919507306-3af7abc8-976e-4bc5-a1da-dde44683f336.webp)



解析：

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640919526377-10d08c15-19a6-4abc-818b-29cf128926cc.webp)



### 二、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640920078932-ed07d277-4f3c-4540-b484-041a7a15f0ae.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640920060506-006782c9-837c-4444-bac7-34bd1f152942.webp)



### 三、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641295723812-aaf27bf2-6102-4b05-8a45-1b788fb232a4.webp)



答案:11 12 0

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641295804196-13111ecf-851a-47d4-81dc-acd61ae53219.webp)



### 四、很难的闭包

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641455833721-6d541a4f-261a-459e-a030-77a052cb6e5f.webp)

