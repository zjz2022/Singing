## 内存泄漏

**什么叫内存泄漏**

 本该被清除的对象，被可到达对象引用以后，未被正确的清除而常驻内存。这种对象如果一直增加，达到内存上限之后，就会造成内存溢出，程序崩溃。V8引擎，在每一次 GC 时，是根据 root 对象依次梳理对象的引用，如果能从 root（global） 的引用链到达访问，V8 就会将其标记为**可到达对象**，反之为**不可到达对象**。被标记为不可到达对象（即无引用的对象）后就会被 V8 回收。

**内存的结构是什么样的**

一个由C/C++编译的程序占用的内存分为以下几个部分

1、栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

2、堆区（heap） ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。注malloc,calloc,new申请的内存均位于此区。

3、全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。

4、文字常量区 ：常量字符串就是放在这里的。程序结束后由系统释放。

5、程序代码区：存放函数体的二进制代码。

**常见的内存泄漏场景**

1、全局变量

2、闭包

3、事件监听

4、缓存使用不当

5、高CPU使用场景，导致内存没有及时释放，请求堆积溢出。

内存泄漏主要分为：

- 全局性泄漏

全局性内容泄漏出现一般高发于：`中间件`与`组件`中，这种类型的内存泄漏排查起来也是最简单的。

二分法排查

1. 先注释一半的代码（减少一半`中间件`、`组件`、或其它公用逻辑的使用）
2. 随便选择一个接口或新写一个测试接口进行压测
3. 如果出现内存泄漏，那么泄漏点就在当前使用的代码之中，若没有泄漏则泄漏点出现在
4. 然后一直循环往复上述流程大约 20 ~ 60 min 一定可以定位到内存泄漏的详细位置

- 局部性泄漏

大多数内存泄漏的情况都是局部性的泄漏，泄漏点可能存在与某个`中间件`、某个`接口`、某个`异步任务`中，由于这样的特性它的排查难度也较大。这种情况都会做 `heapdump` 进行分析。

```
Heap Dump :堆转储, 后面部分都使用 heapdump 表示，做 heapdump 的工具和教程也非常多比如：chrome、vscode、heapdump 这个开源库
```

1. 确定内存泄漏出现的时间范围
2. 采集 heapdump 数据