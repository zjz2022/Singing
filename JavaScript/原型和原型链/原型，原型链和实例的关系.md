每个函数都有prototype属性，称之为原型

> const array = new Array()  这里 array是实例，数组实例、new Array（）是构造函数（也就是数组）

因为这个属性的值是个对象，也称为原型对象

> prototype这个属性，是一个对象object

作用：

1. 存放一些属性和方法（Object的作用，也就是把属性和方法挂在对“原型”这个对象上）
2. 在JavaScript中通过“原型”这个对象实现继承（用对象实现继承）

```js
const arr = new Array(1,2,3)
arr.reverse()
arr.sort()
```

为什么用构造函数创建数组实例之后，就可以使用reverse，sort这些方法？

因为Array构造函数，就是一个函数，只要是函数，就会有原型（对象）

Array.prototype

构造函数.对象

JS在prototype这个原型对象上，已经挂载了很多方法

这些方法，不直接挂载在构造函数Array上，而是挂载在构造函数的原型对象上

也就是说，这个原型对象prototype，本身就有很多方法

因为这个特点，我们利用构造函数Array生成一个数组实例arr，就可以使用构造函数Array的原型对象上挂载好的各种方法了

这就是为什么，我们声明了一个数组，就可以使用这些方法



既然prototype是挂载在构造函数身上的，那为什么实例就可以使用prototype的方法呢？

好问题！



每个实例对象array都有一个 _ proto _ 属性，用来指向生成自己这个实例的构造函数所挂载的原型对象

```js
const arr = new Array(1,2,3)
arr.reverse()
arr.sort()
console.log(arr._proto_ === Array.prototype) 
```





既然Array.prototype这个构造函数身上的原型对象，它也是一个对象，那它就有_ proto _ ，那 

Array.prototype._ proto _ 是谁呢？ 就是 Object.prototype，它指向最大的这个对象（构造函数）的绑定的原型prototype

同理，再往上找，

Object.prototype._ proto _ 是谁呢？就是 null



通过_ proto _ 可以一层一层地找原型，这一层没有，再上一层，知道返回null

这条线路就是原型链