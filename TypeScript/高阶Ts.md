# 高阶Ts

 为什么要有原型 

原型上所有的方法和属性都可以被构造函数的实例共享，当我们有一个东西需要重复使用的时候，就可以把他放在原型上面，这样就可以被重复使用，比如下面的这张图来说

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1657963165114-edc6ddc9-445d-4c53-a90e-e655368dd941.webp)



实例在内存空间中的状态变更

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1657963269484-cf4a86b7-4e8e-48bc-a6de-cb0a6b918f6c.webp)





原型的特点:

1、不适用原型可能会造成空间浪费

2、增加或修改原型对象的属性或方法后， 所有的实例或叫对象立即可以访问的到 【但创建实例后再覆盖原型除外】

3、



 ts自动重启/运行+Parcel自动打包 

 1.ts自动打包 

（1）初始化 npm init --yes 出现 package.json

（2） 安装 typescript

​	  全局安装 cnpm i typescript -g 或

​	  本地安装： cnpm i typescript -D 或

​	  yarn安装 yarn global add typescript 

​        【cnpm i typescript -D 是 cnpm install typescript --save-dev的缩写】

  (3）生成tsconfig.json文件 

​	 tsc --init 

（4）修改 tsconfig.json 中的配置		 

​        “outDir: "./dist" --outDir是ts编译后生成js文件保存的目录		

​         "rootDir": "./src", --rootDir是自己编写的ts源文件所在的目录		

​          注意: dist src package.json 必须是在一个目录下

（5）编译src目录以及子目录下的ts文件

​	 tsc 【在src当前目录下：输入tsc 注意直接写tsc命令即可】		 

​       【会把src目录以及子目录下的ts文件全部编译成js文件，并全部输出到dist目录中】

（6）安装 ts-node

​	ts-node让node能直接运行ts代码，无需使用tsc将ts代码编译成js代码。【ts-node则包装了node，它可以直接的运行ts代码】

​	全局安装 cnpm i ts-node -g 或

​	本地安装： cnpm i ts-node -D 或

​	yarn安装：yarn global add ts-node 

（6）安装nodemon工具 【自动检测工具】		 

nodemon作用：【nodemon可以自动检测到目录中的文件更改时通过重新启动应用程序来调试基于node.js的应用程序】

​	全局安装 cnpm install -g nodemon 或

​	本地安装： cnpm i nodemon -D 或

​	 yarn安装 yarn add nodemon -D 

（7） 在package.json中配置自动检测，自动重启应用程序

  "scripts": {     "dev": "nodemon --watch src/ -e ts --exec ts-node ./src/app.ts"   }

​	   nodemon --watch src/ 表示检测目录是package.json同级目录src

​	   -e ts 表示nodemon 命令准备将要监听的是ts后缀的文件

​	   --exec ts-node ./src/project/app.ts 表示检测到src目录下有任何变化 都要重新执行app.ts文件



 2.Parcel打包支持浏览器运行TS文件 



​		（1）安装Parcel打包工具：npm install parcel-bundler --save-dev



​		（2）在package.json中给npm添加启动项，支持启动parcel工具包







​		  (3)  启动parcel工具包



​	cnpm run start  【cnpm start】或  npm  run start  【npm start】或 yarn run start 【yarn start】

 ts类/继承/多态 

 1.学习 TS 类的深远意义 

相对以前 JavaScript 不得不用 构造函数来充当”类“，TypeScript 类的出现可以说是一次技术革命。让开发出来的项目尤其是大中项目的可读性好，可扩展性好了不是一点半点。

1、TypeScrip 类的出现完全改变了前端领域项目代码编写模式，配合

2、TypeScript 静态语言，编译期间就能检查语法错误的优势【项目上线后隐藏语法错误的风险几乎为零，相比不用 TypeScript 开发项目，使用 

3、TypeScript 后对前端项目尤其是大中项目的开发 或底层第三方插件，组件库的开发带来的优势已经超乎了想象】。

4、TypeScript 类让前端开发人员开发和组织项目或阅读各大前端框架源码的思维问题的方式变得更先进，更全面了许多。因为类是 OOP【面型对象编程】的技术基石，OOP 思想来自于生活，更利于开发人员思考技术问题。

5、TypeScript 类已经成了每次前端面试的高频面试考点。

在前端各大流行框架开发的项目中，比如 Vue3 项目，Angular项目， 基于 Antd UI 库的项目 还是后端 Nodejs 框架，比如：Nestjs，亦或是 Vue3 底层源码，都可以频频见到类的身影。

尽管 TypeScript 类照搬了 Java 后端语言的思想，但 TypeScript 类的底层依然是基于 JavaScript 的，这一点对于前端工程师更深入理解 TypeScript 打开了一条理解之道，提升他们更深厚的 JavaScript 功底从而为面试加分和项目的运用都提供了间接的帮助。



 2.TypeScript 哪些技能基于类？ 

TypeScript 类是 OOP 的技术基石，包括类、属性封装丶继承、多态、抽象丶泛型。紧密关联的技术包括方法重写，方法重载，构造器，构造器重载，类型守卫，自定义守卫，静态方法、属性，关联引用属性，多种设计模式等。



 3.什么是类  

定义：类就是拥有相同属性和方法的一系列对象的集合，类是一个摸具，是从这该类包含的所有具体对象中抽象出来的一个概念，类定义了它所包含的全体对象的静态特征和动态特征。

类有静态特征和动态特征【以大家最熟悉的人类为例】静态特征【软件界叫属性】姓名，年龄,地址,身份证号码,联系方式,家庭地址,微信号动态特征【软件界叫方法】吃饭，走路

【再看桌子类】

静态特征【属性】高度，宽度，颜色，价格，品牌，材质

动态特征【方法】承载

【来看订单类】 

静态特征 【属性】 订单号【订单id】，下单时间，下单顾客，订单详情，顾客微信，收件地址，负责客服

动态特征 【方法】 下单，修改订单，增加订单，删除订单，查询订单，退单 【这一些方法真正开发会归为OrderService 类】 但从广义来说都同属于订单系列类的方法。



 4.理解子类 

（1）什么是子类？ 

有两个类，比如 A 类和 B 类，如果满足 A 类 is a kind of B类，那么 A 类就是 B 类的子类比如：A 类是顾客类，B 类是人类，因为顾客类 a kind of 人类成立【顾客类是人类的一种】，所以顾客类是人类的子类。

（2） 子类如何继承父类的属性和方法？

以顾客类为例子：顾客类继承了父类【人类】的非私有的属性和方法，也具备子类独有的属性和方法 。

顾客类继承父类【人类】的全部非私有的属性和方法外，还有哪些独有的属性和方法呢？顾客类独有属性：顾客等级，顾客编号 顾客类独有方法：购买



 5.什么是对象 

(1) 什么是对象【实例】？

就是一个拥有具体属性值和方法的实体，是类的一个具体表现，一个类可以创建1个或者多个对象

(2) 如何通过类来创建对象 【实例】？



(3) 如何根据People类来创D建叫张三对象【实例】的人？

【举例】

let kateCust=new Customer() kateCust 是对象变量名 ，new Customer() 表示 new 出来的是一个Customer对象，而且是运行期间才在堆中分配 Customer 对象的内存空间 【 new 就是分配内存空间的意思】

（4）类的对象变量丶对象内存图展示

（5）类的对象变量，对象的关系

类的对象变量存在栈中，对象变量存储着对象的首地址，对象变量通过这个地址找到它的对象 



 6.类的原理 

1.类上面有一些属性，这些属性在typescript4.0之前是需要赋值或基于联合类型undefined的

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664368332205-5f735eb0-9227-47f0-af57-8a5d2b1c4a61.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664367311847-1604649e-b342-41ab-b8b6-c9a65ded543f.webp)





2.当你new一个class类的时候他会自动去匹配相应的构造器constructor，看你在类中写的construct是否符合传入参数的数量

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664368435486-32fcc1ac-ac00-431e-83bc-44fb2425ef80.webp)





3.创建对象三件事情

(1)在堆中为类的某个对象实例分配一个空间

(2)调用对于的构造函数(匹配构造器)

(3)把对象赋值给对象变量(对象变量是一个集合)



4.类的本质是原型，类方法是定义在原型上的方法

 7.类的引用属性 

（1）什么是引用属性：如果类中的属性的类型是引用类型，那么这个属性就是引用属性

引用属性的数据类型一般有数组 ，函数，类，对象类型[{.... }格式]，对象数组类型，集合类【Set，Map,自定义集合类】

（2） 引用属性的经典应用场景 

我们举几个经典的案例：

真实应用场景1： 底层经典案例：如果我们使用 TypeScript 来开发一个 ES6 的 Set 集合类就是对数组的二次包装，在这个 Set 集合类中就需要包含一个数组的引用属性供Set类的各个方法来使用。

真实应用场景2：底层经典案例：Promise 是前端很重要的技术，Promise 底层类中就采用了函数类型的引用属性【大家先只需要知晓，本课程后面章节会自己动手开发一个 Promise】。

真实应用场景3：二次封装应用场景：Set 集合虽好，但不能使用 get(index) 直接取值，这也造成了取值不方便，如果我们自己动手封装一个包含了 add、get、remove、delete、query 的集合类【ArrayList】，这时也需要借助数组引用属性 。

真实应用场景4：各种 Nodejs 后端项目构建的应用场景：我们以同学们相对熟悉的订单详情类和订单类为例，下面我们说明并定义电商平台必用的两个类——订单详情类【OrderDetail】和订单类【订单类】转至1.2 。

真实应用场景5：跨前端领域的 Java 后端大量使用了引用属性。【第5点可以先知道下即可】。

案例:

1.定义一个Order类

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664385080349-d09a6ab5-c4f4-4b66-90db-c709e945dee5.webp)



2.定义一个订单详情类

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664385112500-d464c1d6-3a9b-4529-984b-c2a3e94bc7a9.webp)



3.在Order中通过引用属性应用订单详情类

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664386088216-8e641008-cb17-4f47-96c5-47ec3c15a19f.webp)



 8.类构造器赋值方式 

1.定义属性后再构造器中赋值

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664386192958-1901b3ea-c40f-4468-a228-c24c5bf1bc2e.webp)



2.直接在构造器里进行隐式的构造

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664386565648-65b21883-388f-45cf-b658-2919f5ce1d41.webp)



3.用undefined解决ts4.0之前声明的报错

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664386860165-bc5ccad2-162b-4ecf-9fdc-6db78ae9e9d1.webp)



4.用！解决ts4.0之后声明的报错，不会由于undefined造成的空值报错

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664387049351-7133874b-f5ee-46f8-b3de-72f822e33007.webp)





 ts函数重载/泛型函数重载 

 1.为什么要使用函数重载 

写一个简单的需求，通过id和type值获取数据表中的某项数据或数组

不用函数重载时：

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664439836119-8f1f3d5f-117b-4633-8d08-d2f8cb3ae6a3.webp)



 2.函数重载，方法重载的重要性 

著名前端流行框架底层都用到函数重载，例如：Vue3 底层源码就多处使用到带泛型的函数重载【对于泛型先知晓下即可，我们会在第4章我们会融合 Vue3 源码来深度讲解泛型函数重载，本章深度讲解的是非泛型的函数重载，掌握好了泛型函数重载，就具备了学习泛型函数重载的基础】。很多前端面试更是拿函数重载作为考核求职者 TS 技能是否扎实的标准之一，如果你不掌握函数重载，等于你的 TS 技能有缺失，技能不过关。

函数重载或方法重载适用于完成项目种某种相同功能但细节又不同的应用场景【先了解即可，后面我们会结合真实应用场景讲解】 我们举一个生活中的例子让同学们先有个印象，比如：吃饭是一个函数，表示一个吃饭功能，但西方人用叉子，中国人用筷子，这就是细节不同，那如果我们可以用函数重载来解决。

不管现阶段你公司的项目中是否用到了函数重载和方法重载【如果没有用，多半是公司不少人用的并不熟练才不用的缘故】，如果学完后，你能适时给公司提建议，建议项目中合适的场景中使用函数重载并说明原因，你的建议应该很受欢迎！

函数重载或方法重载有以下几个优势：

优势1： 结构分明

让 代码可读性，可维护性提升许多，而且代码更漂亮。

优势2： 各司其职，自动提示方法和属性：每个重载签名函数完成各自功能，输出取值时不用强制转换就能出现自动提示，从而提高开发效率】

优势3： 更利于功能扩展

这三点优势大家先记住即可，学完方法重载后大家就会理解。

同时对于方法和函数分不清的同学，后面老师也会给出答案，同学们可以先把函数和方法等同起来。



 3.TS 函数重载定义 

TS 的函数重载比较特殊，和很多其他后端语言的方法重载相比，多了不少规则。学习函数重载，先要了解什么是函数签名，定义如下：

函数签名 [ function signature ]：函数签名=函数名称+函数参数+函数参数类型+返回值类型四者合成。在 TS 函数重载中，包含了实现签名和重载签名，实现签名是一种函数签名，重载签名也是一种函数签名

以下就是一种函数签名:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664451337407-dc179833-5d9b-4784-88b8-2006cd7d0a42.webp)



关于函数重载的定义，我们先来看一个很多其他资料提供的不完整且模糊的TS函数重载定义：

不完整模糊的 TS 函数重载定义：一组具有相同名字，不同参数列表的和返回值无关的函数 。

完整的函数重载定义：包含了以下规则的一组函数就是TS函数重载 【规则内容多，大家要多记，多实践方可】

规则1：由一个实现签名+ 一个或多个重载签名合成。

规则2： 但外部调用函数重载定义的函数时，只能调用重载签名，不能调用实现签名，这看似矛盾的规则，其实 是TS 的规定：实现签名下的函数体是给重载签名编写的，实现签名只是在定义时起到了统领所有重载签名的作用，在执行调用时就看不到实现签名了。(调用者是重载签名)

规则3：调用重载函数时，会根据传递的参数来判断你调用的是哪一个函数 

规则4: 只有一个函数体，只有实现签名配备了函数体，所有的重载签名都只有签名，没有配备函数体。

规则5: 关于参数类型规则完整总结如下：

实现签名参数个数可以少于重载签名的参数个数，但实现签名如果准备包含重载签名的某个位置的参数 ，那实现签名就必须兼容所有重载签名该位置的参数类型【联合类型或 any 或 unknown 类型的一种】。

规则6： 关于重载签名和实现签名的返回值类型规则完整总结如下：

必须给重载签名提供返回值类型，TS 无法默认推导。

提供给重载签名的返回值类型不一定为其执行时的真实返回值类型，可以为重载签名提供真实返回值类型，也可以提供 void 或 unknown 或 any 类型，如果重载签名的返回值类型是 void 或 unknown 或 any 类型，那么将由实现签名来决定重载签名执行时的真实返回值类型。 当然为了调用时能有自动提示+可读性更好+避免可能出现了类型强制转换，强烈建议为重载签名提供真实返回值类型。

不管重载签名返回值类型是何种类型【包括后面讲的泛型类型】，实现签名都可以返回 any 类型 或 unknown类型，当然一般我们两者都不选择，让 TS 默认为实现签名自动推导返回值类型。

何时能用unknown何时能用any

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664453086246-a705df26-4bb9-4534-9331-91b3835029e8.webp)



any可以作为一个类型的父类，也可以作为一个类型的子类

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664453120050-6ab7a51e-fd7c-49a5-8f96-6badc688443f.webp)



unknown只能作为其他类型的父类，不能作为其他类型的子类



 4.TS方法重载 

1.方法和函数区别，理解方法签名

方法：方法是一种特定场景下的函数，由对象变量【实例变量】直接调用的函数都是方法。

比如：

1函数内部用 this 定义的函数是方法； 

2TS 类中定义的函数是方法【 TS 类中定义的方法就是编译后 JS 底层 prototype 的一个函数】； 

3接口内部定义的函数是方法【注意：不是接口函数】；

4type 内部定义的函数是方法【注意：不是 type 函数】。

方法签名：和函数签名一样，方法签名 = 方法名称 + 方法参数 + 方法参数类型 + 返回值类型四者合成。

2.通过方法重载写一个java版本的arraylist

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664455858405-cafd0ab8-4508-44b8-abd6-17589693595a.webp)



 5.构造器重载的应用 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664457424579-272fd9f1-08f4-44ca-9cbd-2e5afb40c4f6.webp)







 ts单例模式 

 单件设计模式1 

（1） 了解设计模式

设计模式通俗的讲，就是一种更好的编写代码方案，打个比喻：从上海到武汉，你可以选择做飞机，做轮船，开车，骑摩托车多种方式，把出行看成是编码，那么选择飞机相对就是一个更好选择的优化方案。

（2） 常见设计模式概述

常见的设计模式有单件设计模式，简单工厂设计模式，工厂方法，抽象工厂设计模式，观察者设计模式，装饰设计模式，代理设计模式，MVC，MVP, MVVM 架构设计模式。本课程讲解单件设计模式，原因有两个： 1. 设计模式并非 TypeScript 课程的重点，我们要把更多时间留给TS核心技能。 2. 单件设计模式虽短小精悍，但能更好的帮助掌握 TS 类，类的静态方法，类构造器，类对象的联合运用。 

（3）单件设计模式的两种定义和定义中的存在的陷阱

简明定义1：一个类对外有且仅有一个实例【只提供一个实例】，这种编码方案就是单件设计模式。

完整定义1：如果某个类对外始终只提供一个对象【实例】，并且在该类的内部提供了一个外部访问该对象的方法或该对象属性，那么这种编写代码方案【就是设计模式】就是单件设计模式。

完整定义2：如果一个类的任何外部通过访问类提供的某个方法或某个属性始终只能获取该类一个对象【实例】，但如果该类提供了多个外部可以访问的方法或属性，那么外部就能访问到该类的多个不同的对象，但从实际开发来看，绝大多数情况的应用场景，我们对外都只提供一个唯一的可以访问的方法或属性，这样就保证了实例为单个，类的这种编写代码的方案【就是设计模式】就是单件设计模式。

哪一种定义对？

（4） 何时需要使用单件设计模式？

实际开发中，外部访问某个类的对象【实例】时，确保只能访问该类的唯一对象时才能保证逻辑的正确性时，这时就应该使用单件设计模式了。

（5）前端领域单件设计模式的真实应用场景

应用场景1：比如 Vuex，React-Redux 中的全局状态管理容器 store 对象在整个项目被设计成唯一的对象【实例】，把 store 对象所在 的类设计成单件设计模式将是最好的设计方案 【当然也可以有其他替代写法】

应用场景2：一般前端项目需要进行客户端本地数据存储时，都会考虑使用 localStorage，localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份 localStorage 数据。那封装 localStorage设计成一个单件设计模式类就再合适过了。【尽管也可以其他写法，但依然存在问题，编码时我们会给同学们说明】。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664470382315-c2569d67-a076-43ec-8f36-f23b0ce802a4.webp)



应用场景3：我们知道项目日志记录是一个项目中必不可少的环节，当我们为一个项目编写一个日志文件类，用来保存日志和阅读日志信息时，这个日志文件类可以有多种设计方案，但把类写成单件模式是最好的方案，因为每次存储日志信息到日志文件上时都创建一个日志对象，这既没有必要，也很浪费内存空间。

 单件设计模式之localStorage类 

1.什么是静态属性static

​     1.带static关键字的方法就是一个静态方法

​     2.静态方法和对象物管，外部的对象变量不能调用静态方法和静态属性

​     3.外部可以通过类名来调用

\2. 外部如何调用 TS 类的静态成员？答：类名直接调用静态成员，格式：类名.静态属性 类名.静态方法。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664471875437-39a6c08b-65b8-42bc-9f73-23434fd33ef6.webp)



\3. TS类的一个静态方法如何调用其他的静态成员？ 答：使用 this 来获取静态成员。

\4. 静态方法是否可以访问类中原型对象上的方法或对象属性【对象基本类型数据+对象引用属性】，反过来呢? 答：都不能。

\5. 对象变量是否可以访问静态成员？答：不能外部对象不能调用。

\6. 一个静态方法改变了某个静态属性，其他静态方法或类外部任何地方访问这个属性都会发生改变。

\7. 静态成员保存在内存哪里？何时分配的内存空间呢？

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664507796604-b76dd48a-b9d5-47eb-a62b-5795cdc703d8.webp)



答：任何一个 TS 类中的静态成员存储在内存的静态区，运行一个 TS 类，TS首先会为静态成员开辟内存空间，静态成员的内存空间分配的时间要早于对象空间的分配，也就是任何一个对象创建之前 TS 就已经为静态成员分配好了空间。但一个静态方法或静态属性只会分配一个空间，只要当前服务器不重启或控制台程序还没有结束之前【如果是开发期间临时测试，一般用控制台】，那么静态方法或者是静态属性就一直存在内存空间，无论调用多少次这个静态方法或静态属性，都是调用的同一块空间。

总结静态方法，两点：

总结1： 无论你是否创建对象，创建多少个对象，是否调用该静态方法或静态属性，TS都会为这个静态方法或静态属性分配内存空间，注意：静态成员和对象无关。

总结2：一旦为静态方法或静态属性分配好空间，就一直保存到内存中，直到服务器重启或者控制台程序执行结束才被释放。

彩蛋：new 一个 TS 类的方法可以吗？能在TS 类外部使用 prototype为TS类增加方法或属性吗?

虽然在 JS 中可以 new 一个类【构造函数】内部定义的对象方法或静态方法，但TS已经屏蔽了去new 一个类中的方法【 JS 可以，会当成一个构造函数】，TS 类可以访问 prototype 原型对象属性，但无法在 prototype 原型对象属性增加新的方法或属性，这么做，就是让我们只能在类的内部定义方法，防止回到 ES5 从前非面向类和对象的而写法。【但是可以覆盖类上已经存在的方法】	

\8. 静态方法是否可以接受一个对象变量来作为方法的参数？

答：可以，静态方法内部不能通过this来访问对象属性和方法，但可以通过调用静态方法时把对象变量传递给静态方法来使用。比如：我们把 js 的 Object 构造函数想象成一个 TS 类【实际 TS 类编译后的 JS 文件中就变成了一个构造函数】。Object 类就拥有大量的静态方法，例如：apply，call，bind，keys等，现在我们来关注静态方法是否可以接受对象变量作为方法的参数，我们以Object.keys方法为例 【Object类的keys方法用来获取给定对象的自身可枚举属性组成的数组】。



\9. 何时应该把一个方法定义成静态方法或属性定义为静态属性呢？【应用】

答: 应用1：单件设计模式就是静态方法和静态属性很好的应用场景之一。当外部不能创建对象，就只能借助类内部的静态方法来获取类的对象；这时肯定不能把这个方法定义成原型对象属性上的方法，只能定义为类的静态方法，因为如果定义成原型对象属性的方法，就会导致外部无法被访问，因为外部根本不能创建对象，也就无法访问原型对象属性上的方法。而静态方法要访问的属性就只能是静态属性了，这也是静态属性的应用时机。

​	应用2：当类中某个方法没有任何必要使用任何对象属性时，而且使用了对象属性反而让这个方法的逻辑不正确，那既如此，就应该禁止这个方法访问任何对象属性和其他的对象方法，这时就应该把这个方法定义为静态方法。例如：一个顾客类的购买方法【 buy 方法】中肯定要允许访问顾客姓名或其他顾客微信这些对象属性，这样的方法我们就需要定义在原型对象属性上，但如果顾客类中的 阅读顾客积分公告方法【 readNotice 方法] 是针对全体顾客的公告方法，就应该定义为静态方法，方法内部就应该禁止出现任何具体的对象属性。如果在这样的方法中使用了顾客的某个属性，比如用了顾客姓名，那么这个方法逻辑就不正确【这个方法就会说：你让我向全体顾客展示公告，你我要知道每个顾客姓名做什么？】。所以我们应该让这样的方法禁止访问对象属性和其他的对象方法，那就应该设置为静态方法。

应用3：当一个类中某个方法只有一个或者 1-2个 对象属性，而且更重要的是，你创建这个类的对象毫无意义，我们只需要使用这个类的一个或者多方法就可以了，那么这个方法就应该定义为静态方法。常见的工具类中的方法通常都应该定义为静态方法。比如 StringUtil, FileUtil 等，我们以 FileUtil 为例进行讲解

思考题：定义一个文件工具类【 FileUtil 】，编写一个读取文件方法【readFile方法】方便外部调用，那这样的方法应该定义为静态方法吗？

答：定义在原型属性上和定义为静态方法似乎都可以，只要 readFile 方法获取到外部提供文件名就可以展开文件读写。请看下面两段代码，我们仔细比较后再来决定用哪一种方案？

使用静态方法



不使用静态方法



\10. 对于第 9 项思考题中的关于使用静态属性或静态方法的解决方案绝对不能用在学生，顾客其他应用场景，那样会导致三个比较严重的问题，以学生对象为例：

1浪费了很多不必要的内存空间

运行一开始就为大量的静态属性和大量的静态方法分配内存空间【但很可能某个静态方法一直没有使用，白白的一直占用着内存空间】

1无法展示一个学生一个对象的直观效果，完全失去了对象来描述实体的优势！

2最严重的问题是：属性值一变则都变

所有操作都在用一个静态方法空间来完成某种功能，一旦某个操作改变了静态方法中的某个值，比如改变了学生姓名，则其他操作访问到这个静态变量看到的结果全变了。

 单件设计模式实现方式2 

（1）饿汉式单件设计模式定义【实现步骤见第（3）步】

饿汉式单件设计模式是无论你是否用到了对象【实例】，一开始就建立这个唯一的对象。

（2）懒汉式单件设计模式实现步骤

构建单件设计模式[懒汉式[等到需要使用对象时才创建对象,按需创建]单件设计模式 ]

第一步：把构造器设置为私有的，不允许外部来创建类的实例【对象】

第二步: 至少应该提供一个外部访问的方法或属性，外部可以通过这个方法或属性来得到一个对象

所以应该把这个方法设置为静态方法

第三步：外部调用第二步提供的静态方法来获取一个对象



（3）饿汉式单件设计模式实现步骤

​	构建单件设计模式[饿汉式单件设计模式 立即创建对象]

第一步：把构造器设置为私有的，不允许外部来创建类的实例【对象】

​	 第二步: 建立一个静态引用属性，同时把这个静态引用属性直接指向一个对象【 new MyLocalStorage()】

​	 第三步：外部调用第二步提供的静态方法来获取一个对象





 ts策略模式 

 ts多种继承模式 

 原型链继承 

说明：Parent 类是【父构造函数】 Son 类是【子构造函数】

原型链继承基本思想就是Son 类的原型对象属性【 Son.prototype 】指向 new Parent( )。即 



原型链继承实现的本质是改变Son构造函数的原型对象变量的指向【 就是Son.prototype的指向 】，Son.prototype= new Parent ( )。那么 Son.prototype 可以访问 Parent 对象空间的属性和方法。所以顺着 [proto ]属性 ，Son类也可以访问 Parent 类 的原型对象空间中的所有属性和方法。

原型链继承查找属性和方法的完整路线描述: 子对象首先在自己的对象空间中查找要访问的属性或方法，如果找到，就输出，如果没有找到，就沿着子对象中的proto属性指向的原型对象空间中去查找有没有这个属性或方法，如果找到，就输出，如果没有找到，继续沿着原型对象空间中的proto查找上一级原型对象空间中的属性或方法，直到找到Object.prototype原型对象属性指向的原型对象空间为止，如果再找不到，就输出null

（2）原型链继承实现容易被遗忘的重要一步

​		Son.prototype.constructor = Son

（3） 原型链继承常见疑问

Son.prototype= Parent.prototype 这样作为原型链继承的模式和 Son.prototype=new Parent (...) 又有什么区别呢？

（4）原型链继承的不足

局限性：不能通过子类构造函数向父类构造函数传递参数



 借用构造函数继承 

（1）借用构造函数继承如何解决原型链继承的局限性

借用构造函数继承思想就是在子类【 ChinesePeople 构造函数】的内部借助 apply ( ) 和 call ( ) 方法调用并传递参数给父类【 People 构造函数】，在父类构造函数中为当前的子类对象变量【ChinesePeopl对象变量】增加属性【本例中增加了name,



（2）借用构造函数继承的不足

借用构造函数实现了子类构造函数向父类构造函数传递参数，但没有继承父类原型的属性和方法，无法访问父类原型上的属性和方法。





 借用构造函数+原型链继承组合模式 

（1）借用构造函数+原型链继承组合模式的优势

优势1：具备借用构造函数的优点：子类【 ChinesePeople 构造函数】的内部可以向父类【 People 构造函数】 传递参数

优势2：具备原型链继承的优点：ChinesePeople.prototype 和 new ChinesePeople( ) 出来的实例对象变量和实例都可以访问父类【 People 构造函数】 原型对象上的属性和方法。



（2）借用构造函数+原型链继承组合模式的不足：

​	 缺点：调用了两次父类构造函数 【 People 构造函数】 new People 调用构造函数带来问题： 

1进入 People 构造函数为属性赋值，分配内存空间，浪费内存；

2赋值导致效率下降一些，关键是new People 赋的值无意义，出现代码冗余，new ChinesePeople出来的对象和这些值毫不相干，是通过子类 ChinesePeople 构造函数中的 apply 来向父类People构造函数赋值。



 寄生组合继承 

寄生组合继承模式=借用构造函数继承+寄生继承。

寄生组合继承既沿袭了借用构造函数+原型链继承两个优势，而且解决了借用构造函数+原型链继承调用了两次父类构造函数为属性赋值的不足。寄生组合继承模式保留了借用构造函数继承，寄生组合继承模式使用寄生继承代替了原型链继承。

什么是寄生继承呢？就是 ChinesePeople.prototype 不再指向 new People( ) 出来的对象空间，而用 People 类 【父构造函数】的原型对象属性“克隆”了一个对象。再让ChinesePeople.prototype指向这个新对象，很好的避免了借用构造函数+原型链继承调用了两次父类构造函数为属性赋值的不足。

具体执行步骤见下面代码。

解释 S99 行代码：表示创建了一个新对象，相当用 People 类 【父构造函数】的原型对象属性“克隆”了一个对象。

解释 S100 行代码：让ChinesePeople 原型对象变量指向S99



 TS继承+TS继承好处 

\1. 理解子类

（1）什么是子类？ 

有两个类，比如 A 类和 B 类，如果满足 A 类 is a kind of B类，那么 A 类就是 B 类的子类比如：A 类是顾客类，B 类是人类，因为顾客类 a kind of 人类成立【顾客类是人类的一种】，所以顾客类是人类的子类。

（2） 子类如何继承父类的属性和方法？

以顾客类为例子：顾客类继承了父类【人类】的非私有的属性和方法，也具备子类独有的属性和方法 。

顾客类继承父类【人类】的全部非私有的属性和方法外，还有哪些独有的属性和方法呢？顾客类独有属性：顾客等级，顾客编号顾客类独有方法：购买

(3) 初步理解为什么要用继承？

举例：宠物管理项目中的狗狗类，兔子类，小猫类都是宠物，尽管每个宠物都有独有属性和方法，比如狗狗类的品种，看家方法；兔子类的肤色属性等。但这些类都包含了 name, buymoney[购买价格]，healthstatus[健康状况]，friendshipstar [和主人的友谊星级数]这些属性，如果每一个类都写这些属性，那么就非常臃肿，可以把这些属性提取出来放到一个宠物类中，其他类都继承这个宠物类。当然继承还有更多好处，下面借助汽车租赁功能的实现来更深度的掌握继承。

(4) 汽车租赁管理功能【深度掌握继承】

需求1:汽车租赁功能实现: 有小轿车,大巴,卡车三种类型的车,顾客可以租任意一种或多种不同类型的车,按照租用的天计算租金， 同时为了响应国家对各类车安全的管理, 对在租赁期内有过各种超载，超乘客数，酒后驾车等违规的车需额外支付一定的费用。

需求2:计算退回费用：最终退回顾客的费用为押金扣除使用天数，如押金不足需额外支付不足部分。

思考小轿车,大巴,卡车共同属性: 品牌 ( brand ) VechileNo ( 车牌号 ) days ( 租赁天数 ) total ( 支付的租赁总费用 ) deposit ( 押金 )

思考小轿车,大巴,卡车共同方法: 计算租赁车的价格 ( calculateRent) 支付押金的方法( payDesposit)

​										安全规则方法（safeShow)

父类：Vechile 交通工具。

// 子类 小轿车 【型号】type属性

2.super+方法重写的真应用

方法重写：（override)

条件：一定发生在继承的子类中

位置： 子类中重写父类的方法

应用场景：当父类中方法的实现不能满足子类功能需要或不能完全满足子类功能需要时，就需要在子类中进行重写

方法重写给继承带来的好处: 让所有的子类共用父类中方法已经实现了一部分功能的代码【父类方法代码在各个子类中得到了复用】 

定义规则：

\1. 和父类方法同名 

\2. 参数和父类相同，如果是引用类型的参数，需要依据具体类型来定义。

1父类方法的访问范围【访问修饰符】必须小于子类中方法重写的访问范围【访问修饰符】同时父类方法不能是private 

super的两种用法【super只能出现在子类【派生类】中】

用法1：在子类的构造函数中使用 super (子类传递给父类构造函数的参数) 就表示用来调用父类构造函数 (传递给父类构造函数的参数)

还记得吗？super 编译成 JS 源码后 可以看到：就是采用 JS 原型中的借用构造函数来实现的

用法2：在子类重写的方法中调用父类同名方法，super.重写的方法

错误用法：当子类和父类有同名属性时，可以在子类中用 super 来获取父类同名属性吗？【不能】【一般要避免在子类，父类属性名同名】

通过super继承

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664540315318-5f53fcb6-7c97-4673-8d3a-390928f58024.webp)



子类重写方法但还想调用父类方法

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664540488154-4553ccc9-bb9c-4467-81f5-e50025f2078a.webp)



 手写TS 继承编译的 JS 源码 

（1）相关技术：setPrototypeOf 使用+ 和 Object.create 的区别；

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664543853413-c1f924e9-0eaf-4a1a-9014-276a11dcaaf4.webp)



  (2) 父类静态方法和属性在子类中的继承：setPrototypeOf 和 Object.create 分别实现；

（2） 深度掌握 +手写+优化底层 extendsStatics 方法的实现；

​		extendsStatics 方法的作用： 完成父类静态方法和属性在子类中的继承

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664545115377-20281b4e-f91d-4796-b9c4-8348c4ccb847.webp)





（3）深度掌握_extends 方法



 ts类型断言、类型守卫、多态和抽象类 

 类型断言 

（1）TS 类型断言定义：把两种能有重叠关系的数据类型进行相互转换的一种 TS 语法，把其中的一种数据类型转换成另外一种数据类型。类型断言和类型转换产生的效果一样，但语法格式不同。

（2）TS 类型断言语法格式：A 数据类型的变量 as B 数据类型 。A 数据类型和 B 数据类型必须具有重叠关系

（3）重要细节：理解重叠关系：以下几种场景都属于重叠关系 

1如果 A，B 如果是类并且有继承关系【 extends 关系】无论 A，B 谁是父类或子类， A 的对象变量可以断言成 B 类型，B 的对象变量可以断言成A类型 。但注意一般在绝大多数场景下都是把父类的对象变量断言成子类。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664612682834-2deec40c-1a27-4af9-80b0-bb2b0c75650d.webp)



2如果 A，B 如果是类，但没有继承关系两个类中的任意一个类的所有的 public 实例属性【不包括静态属性】加上所有的 public 实例方法和另一个类的所有 public 实例属性加上所有的 public 实例方法完全相同或是另外一个类的子集，则这两个类可以相互断言，否则这两个类就不能相互断言。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664612831565-05e787e5-3f92-47ff-8295-af6f6c92ca64.webp)



3如果 A 是类，B 是接口，并且 A 类实现了 B 接口【implements】，则 A 的对象变量可以断言成 B 接口类型，同样 B 接口类型的对象变量也可以断言成A类型 。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664613984550-3cfe266a-0e1d-4c99-86e5-47a4cea663a9.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664614062755-3091882f-efdc-4f95-a569-dfdc59131832.webp)



4如果 A 是类，B 是接口，并且 A 类没有实现了 B 接口，则断言关系和第2项的规则完全相同。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664613973602-91207501-f4c9-40db-8beb-5c9fb89a6666.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664614076983-fc8492ba-09d8-4e7e-90bb-507b57fd477c.webp)



5如果 A 是类，B 是 type 定义的数据类型【就是引用数据类型，例如 Array, 对象，不能是基本数据类型，例如 string，number,boolean】，并且有 A 类实现了 B type 定义的数据类型【 implements】，则 A 的对象变量可以断言成 B type 定义的对象数据类型，同样 B type 定义的对象数据类型的对象变量也可以断言成 A 类型 。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664614101138-01926ca4-78af-489d-a1d7-7f9fd370943b.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664614112086-2ddb2a88-9fb1-45cd-bae5-1f57a3602a44.webp)



6如果 A 是类，B 是 type 定义的数据类型，并且 A 类没有实现 B type定义的数据类型，则断言关系和第2项的规则完全相同。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664614129672-abcde904-9d72-43f2-9b10-7a4512be04c2.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664614147165-a97af8c2-11da-4073-b440-f26c17b133c0.webp)



7如果 A 是一个函数上参数变量的联合类型，例如 string |number，那么在函数内部可以断言成 string 或number 类型。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664614171257-ba9d092c-6c30-4c51-bc6e-28e67a6825d5.webp)



8多个类组成的联合类型如何断言？例如：let vechile: Car | Bus | Trunck。 vechile 可以断言成其中任意一种数据类型。 例如 vechile as Car， vechile as Bus ， vechile as Trunck 。

9任何数据类型都可以转换成 any 或 unknown 类型，any 或 unknown 类型也可以转换成任何其他数据类型。

（4）类型断言存在的意义和应用场景：

场景1：顾客在执行汽车租赁项目租赁价格计算方法中调用每一个类的独有方法时使用

​		场景2：对象中的 Symbol 数据类型取值问题

场景3： 加法计算，巧用 as any。



 new 底层发生了什么？ 





 TS 类型守卫 

为什么要用类型守卫：

类型守卫定义： 在 语句的块级作用域【if语句内或条目运算符表达式内】缩小变量的一种类型推断的行为。

类型守卫产生时机：TS 条件语句中遇到下列条件关键字时，会在语句的块级作用域内缩小变量的类型，这种类型推断的行为称作类型守卫 ( Type Guard )。类型守卫可以帮助我们在块级作用域中获得更为需要的精确变量类型，从而减少不必要的类型断言。

●类型判断：typeof

●属性或者方法判断：in

●实例判断：instanceof

●字面量相等判断：==, ===, !=, !==



 typeof 的局限性与解决方案 

typeof 作用

typeof 用来检测一个变量或一个对象的数据类型。

typeof 检测的范围

typeof 检测变量的类型范围包括： “string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function" 等数据类型。

typeof 的局限性

typeof 检测变量并不完全准确，例如 typeof null 结果为 object，这其实设计者的一个 bug， 但后来一直没有被改过来，于是就此传下来了，但把 null 当成 object 的理由说成是 未来可能会拥有一个对象空间，这个理由很牵强【我们检测的是对象变量此刻的类型】，null 本来即是数据类型，也是值。所以 typeof null 直接显示 null 最合适了。 

再例如：使用 typeof 来检测一个数组变量，typeof [ ] 结果显示的是 object, 从 Array 创建的本质上来说确实是 object，正如我们在 2-29-1中所讲，但开发者期待看到的是 Array，这更符合预期。 Array 和我们定义的普通函数一样，具有双重性，当成函数类型时用来创建数组对象，但也是一个构造函数对象，拥有静态成员和prototype原型对象属性。【这一点我们在 TS 继承 课题已经讲过】

再比如：使用 typeof 来检测一个 Set 变量，Map 变量，结果显示的是依然是 object。

typeof 的替代方案

Object.prototype.toString.call 

Object.prototype.toString.call ([ ]) 展示[ object Array ] 

Object.prototype.toString.call(null) 展示[ object null ] 

Object.prototype.toString.call(Set类型的变量) 展示[ object Set ]

Object.prototype.toString.call(Map类型的变量) 展示[ object Map ] 

typeof 的替代方案依然无法解决的问题

就是无法获取一个自定义的类的实例变量或构造函数的对象变量的真正创建类型，答案是使用 instanceof 来解决。



 instanceof 

instanceof 格式： 对象变量 instanceof 类名或函数名

instanceof 的主要作用： instanceof 帮助我们准确的判断一种自定义函数或类创建的对象变量的数据类型。

instanceof 执行后 返回 true 的几种条件【符合一个即可】：

（1） 对象变量.proto=类名或函数名.prototype。 

解释1：如果 instanceof 关键字 左边对象变量的 proto 属性指向的原型对象空间=右边类名或函数名的 prototype 对象属性指向的原型对象空间，那么 返回 true。

（2） 对象变量.proto.proto...._proto__=类名或函数名.prototype。

解释2： instanceof 左边对象变量 proto的1到多个上一级proto指向的原型对象空间，等于右边类名或函数名的 prototype 对象属性指向的原型对象空间，那么也返回 true，按照这个查找规律，会一直找到Object.prototype 对象属性指向的原型对象空间为止。





 ts多态 

1.多态的定义:

父类的对象变量可以接受任何一个子类的对象 

从而用这个父类的对象变量来调用子类中重写的方法而输出不同的结果.

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664623069418-3d6e7c0b-ed90-4b59-b2c1-46ec2937818a.webp)



2.产生多态的条件:

1.必须存在继承关系 2.必须有方法重写

3.多态的好处:

利于项目的扩展【从局部满足了 开闭原则--对修改关闭,对扩展开放】

4.多态的局限性

无法直接调用子类独有方法，必须结合instanceof类型守卫来解决



 TS 抽象类 

一个在任何位置都不能被实例化的类就是一个抽象类【abstract class 】

什么样的类可以被定义为抽象类

从宏观上来说，任何一个实例化后毫无意义的类都可以被定义为抽象类。 比如：我们实例化一个玫瑰花类的对象变量，可以得到一个具体的 玫瑰花 实例对象，但如果我们实例化一个 Flower 类的对象变量，那世界上有一个叫 花 的对象吗？很明显没有，所以 Flower 类 可以定义为一个抽象类，但玫瑰花可以定义为具体的类。

一个类定义为抽象类的样子

abstract class 类名{ 可以有 0 到多个抽象方法【只有方法体，没有方法实现的方法】，可以有 0 到多个具体方法，可以有构造器，可以有 0 到多个实例属性，0 到多个静态属性，0 到多个静态方法 } 单纯从类的定义上来看和普通类没有区别，只是多了可以有 0 到多个抽象方法这一条，并且不能被实例化。

抽象类的特点

可以包含只有方法声明的方法【 和方法签名类似，就是多了 abstract 关键字】，也可以包含实现了具体功能的方法，可以包含构造器，但不能直接实例化一个抽象类，只能通过子类来实例化。

抽象类相比普通类充当父类给项目带来的好处

好处1：提供统一名称的抽象方法，提高代码的可维护性：抽象类通常用来充当父类，当抽象类把一个方法定义为抽象方法，那么会强制在所有子类中实现它，防止不同子类的同功能的方法命名不相同，从而降低项目维护成本。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664625754175-52dbecb1-4391-4fc4-99b2-f6509076449b.webp)



好处2：防止实例化一个实例化后毫无意义的类。

用法:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664630749626-ac89a0fe-b7d9-44a1-b3bb-90c345311875.webp)





 ts自定义守卫 



1.1 自定义守卫是通过 {形参 is 类型} 返回布尔值的赋予类型守卫的能力的条件表达式

自定义守卫格式：

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664631056529-75cdf0a1-7f6d-4445-b4b5-52d3b198a8d9.webp)



理解：返回布尔值的条件表达式赋予类型守卫的能力， 只有当函数返回 true 时，形参被确定为 A 类型

用法:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664631394688-50cd5364-0f08-4ce6-a2b2-7d0055e556de.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664631406585-96a603d9-d95f-4b78-9e83-8ac07ac62c68.webp)



vue3中的自定义守卫

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664631958105-acd18c5c-cacd-4251-85bc-c2f2afbc61db.webp)





 ts4新特性 

const 为何也能被修改？如何解决？

可以用const限制数组，可以用readonly限制形参

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664632566378-c5958c44-7b02-4974-af61-71cf5337cfcb.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664632632938-9a157659-55f2-42b4-b1ce-b547e34c1abf.webp)



为什么要用可变元组+元组标签+具体使用

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664632822774-6682865a-deea-47bd-81f8-db3a56aa86ba.webp)





 ts泛型 

 TS 泛型的重要性 

 泛型类定义+格式 

 object 为什么不能替代类上的泛型？ 

 any 为什么不能替代类上的泛型？ 

原因一：编译期间 any 无法进行类型安全检查，而泛型在编译期间可以进行类型安全检查我们学过: any 是所有类型的父类，也是所有类型的子类如果我们现在是一个宠物店类，希望只能添加 Dog 类，当调用 add 方法添加 Customer、Student 类必定出现编译错误，从而保证了类型安全检查，但是 any 类型无法保证类型安全检查，可以为任意类型，包括 string，number，boolean，null，undefined，never，void，unknown 基础数据类型和数组，类，接口类型， type 类型的变量全部能接受，不会进行无法进行类型安全检查。

原因二：any 类型可以获取任意数据类型的任何属性和任意方法而不会出现编译错误导致潜在错误风险，而泛型却有效的避免了此类问题发生any 类型可以获取任何属性和任意方法而不会出现编译错误，因为any可以代表任意数据类型来获取任意属性和任意方法，但是泛型类型被具体化成某种数据类型后，该数据类型的变量调用该数据类型之外的属性和方法时，出现编译错误，这也减少了代码隐藏潜在错误的风险。

原因三: any 类型数据获取属性和方法时无自动提示，泛型有自动提示

彩蛋：any 类型可以代表任意数据类型来获取任何属性和任意方法而不会出现编译错误，因为any可以代表任意数据类型来获取任意属性和任意方法：【 any 的这个特性是一把双刃剑，当我们需要这么使用，它给我们带来方便，但是大多数情况下我们是不需要这么做的】。

 泛型约束 

 keyof 

 T[K]的使用 

 泛型接口 

**好处1：降低代码管理成本，提供统一属性和方法命名。**



为实现了本接口的所有泛型类提供了统一的方法和属性，避免了不同的泛型类对于相同功能的方法和属性各自命名导致加大代码管理和测试的成本的问题。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664708840409-712975e6-609b-4824-b192-b5158c2892b8.webp)





**好处2：可以从整体上快速通读类的共同方法和属性。**



可以把接口当成一个书的目录，快速查看类的方法和属性，这对于首次了解项目的开发人员来说是大为有好处的。



**好处3：新增相同功能类时，可以快速搭建类的方法。**



**好处4：和多态结合增加了项目的扩展性和简洁度，对开发大中项目有好处**





 ts泛型函数 

 泛型函数重载 

 1.泛型函数实现中文排序

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664711671369-eb582ef0-0c85-4e9b-ab7c-d61fd9d4a787.webp)



\2. 泛型函数实现字符串自排序

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664711709953-420a53cc-b640-47fe-8586-634bba4855ef.webp)



3.中文+英文、数字数组排序

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664713436845-59b43238-f8cb-42ae-a172-4716c153aac5.webp)





4.中文+英文、数字数组 + 数组内部字符串自排序

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664713503007-c214edfc-9e2b-4f47-a88b-d2b96f0467f5.webp)





泛型函数重载的运用

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664722618438-ee77c732-e555-467f-bce6-72ed4d83cf24.webp)





vue3中的泛型函数重载

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664861129088-e29412fd-5083-4ea8-b131-5b5364cf331b.webp)







 泛型工厂函数 

工厂函数是什么

工厂函数类型定义：代表任意一个类的构造函数【等价JS的构造函数】的函数类型。

泛型工厂函数定义：一个可以创建任意类对象的通用泛型函数

泛型工厂函数应用场景： 

使用场景:1：在一些不方便或者没有办法直接 new 类名（）格式来创建对象，例如：后面讲解的装饰器中就多次用到。 

使用场景2：在一些项目测试或者调试中简化代码使用。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664862582144-6bec529c-1e51-4249-93a9-528139c52b39.webp)



接口声明的多种情况

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664862075534-66020fec-541d-4ec0-b6af-7256ae7bf933.webp)







泛型工厂函数

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664877974943-1c5b1f43-755f-4d39-8314-e27238914046.webp)



返回的是一个T类型，这样就可以根据传入的值来获取类型



 ts交叉类型 

1 交叉类型定义丶和联合类型区别

2 交叉类型的应用场景概述

3 举例展现如何使用交叉类型，体验交叉类型好处。

定义：将多个类型合并【多个类型属性和方法的并集】成的类型就是交叉类型。

和联合类型区别：

赋值区别：

对于对象类型合成的交叉类型是多个类型属性和方法的合并后的类型，属于多个类型的并集，必须是两个类型的全部属性和方法才能赋值给交叉类型变量。【可选属性和方法除外】

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664878046468-a5b4ef1b-79f3-471e-85a3-804332e052bc.webp)



对于对象类型合成的联合类型变量可以接受联合类型中任意一种数据类型全部属性和方法，也可以是两个类型的全部属性和全部方法【可选属性和方法除外】，也可以是一种数据类型全部属性和方法+其他类型的某个属性和某个方法。

获取属性和方法区别：

交叉类型变量可以获取两个类型的任意属性和任意方法，而联合类型的变量只能获取两个类型的共同属性和方法【交集属性和交集方法】

交叉类型应用场景

通常用于多个对象合并的场景。比如：我们把用户信息，用户角色信息合并成一个对象然后输出。当然后端可以通过连接查询的 SQL 语句来完成到前端的多对象输出，但大多需要表的外键来支持，比如用户和角色就需要角色表有用户外键，对于现实生活中有必须关联在一起的实体【比如商品和库存信息】一般建议数据表用外键来支持前端多个对象的合并输出，虽然影响了效率，但也保证了表的数据合理性和完整性。

但如果我们临时需要随机把两个根本没有外键关联的数据表取出来的对象合并在一起输出，比如用户信息和日志信息，商品信息和日志信息，订单信息和日志信息，我们就可以用交叉类型来完成。因为我们不可能为了这个临时的对象合并需求把所有的这些表都建立起外键，须知外键太多不仅增加了数据表维护的负担，而且也有较大的影响了表操作效率。

可能没有数据表基础的同学不太理解，效率低到哪了呢？比如添加一个用户，必然要添加日志 id 【外键】信息，那就要判断这个日志 id 是否在日志表中是否存在，这就是需要时间，当用户访问量大时，某个时刻都要完成添加操作【高并发操作】，这个外键时间检查损耗就比较严重，尽管我们通过各种 SQL 优化来提高 SQL 效率, 【就像一个拖着一辆大卡车【 A 表】的大货车【 B 表】，无论如何调优，也不比空跑的大货车快】



交叉类型是并集，联合类型是多个类型之一或多个类型的全部都行

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664878100672-3feef485-26f6-4448-a779-d3b3952215a6.webp)





交叉类型的泛型函数重载，合并两个或三个对象

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664879515177-65f88114-080c-47b8-bbcf-b2dd875a987b.webp)







 ts的推断和高级类型 

 ts的infer推断 

infer 的定义：infer 表示在 extends 条件语句中以占位符出现的用来修饰数据类型的关键字，被修饰的数据类型等到使用时才能被推断出来。

infer 占位符式的关键字出现的位置：通常infer出现在以下三个位置上。

（1）infer 出现在 extends 条件语句后的函数类型的参数类型位置上

（2）infer 出现在 extends 条件语句后的函数类型的返回值类型上

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664880869319-601c0471-7885-43b6-8ae1-b15d6407f2c0.webp)



（3） infer 会出现在类型的泛型具体化类型上。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664881479864-5795679f-30ea-43d7-9dfe-0811adad5b9d.webp)





获取构造函数中构造器的类型

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664883834042-56ce51c5-677c-4aa5-9786-5ef4c308b474.webp)









 ts高级type类型 

 Extract 

基本格式:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664884560537-413735b5-5190-489e-9591-4a230826471d.webp)



一、父子类

定律1：

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664884734874-8288f241-390f-4716-b835-e9d92de02b3e.webp)



定律2:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664885171929-45581c8f-aec3-4f5d-b02a-7c7a86994bc5.webp)



二、联合类型

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664886086055-e0bfea1f-9039-4567-8302-7aeb84411e25.webp)





三、函数类型

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1664886402294-16c330cf-8101-45cf-aedc-5eccaf129a9f.webp)