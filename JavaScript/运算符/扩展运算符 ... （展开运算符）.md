### 扩展运算符 ... （展开运算符）

#### 4.3.1 哪些类型能被扩展操作符?

**类型：**数组、对象、字符串

- 复杂数据类型都可以，当要转化为可迭代数据结构时可设置对象的迭代器对扩展运算符扩展出来的值进行操作。

- 基础数据只有string可以使用扩展运算符，number,boolean,null,undefined无效

#### 4.3.2 扩展运算符的应用场景

```js
// 1、函数调用
function add(x, y) {
	return x + y
}
add(...[4, 38])

function f(a, b, c, d, e) { }
f(1, ...[1, 2], 2, ...[3])

//往数组里push多个元素
var arr1 = ['子异', '坤坤'];
var arr2 = ['说', '唱', '跳'];
arr1.push(...arr2);
console.log(arr1); //['子异', '坤坤','说', '唱', '跳']

//替代函数的apply方法
function f(a, b, c) { }
var args = [0, 1, 2];
f.apply(null, args); 	//ES5 的写法
f(...args); 			//ES6的写法

//求一个数组的最大数简化
Math.max.apply(null, [14, 3, 77]) //ES5 的写法
Math.max(...[14, 3, 77]) //ES6 的写法，等同于Math.max(14, 3, 77)

//扩展运算符后面可以放表达式
const arr = [...(5 > 0 ? ['a'] : []),'b'];
console.log(arr); //['a','b']

//6.与解构赋值结合，用于生成数组
const a1 = [1, 2];
const a2 = [...a1]; //写法1
const [...a2] = a1; //写法2
const [first, ...rest] = [1, 2, 3, 4, 5];
first //1
rest //[2, 3, 4, 5]
const [first, ...rest] = [];
first //undefined
rest //[]
const [first, ...rest] = ["foo"];
first //"foo"
rest //[]
//1234567891011121314151617

//合并数组
[...arr1, ...arr2, ...arr3] //[ 'a', 'b', 'c', 'd', 'e' ]
123
//数组的克隆
var arr1 = [0, 1, 2];
var arr2 = [...arr1];
arr1[0]=100;
console.log(arr2); //[0, 1, 2]
/* 乍一看，arr2与arr1不共用引用地址，arr2不随着arr1变化，接着往下看 */
var arr1 = [0, [1,11,111], 2];
var arr2 = [...arr1];
arr1[1][0]=100;
console.log(arr2); //[0, [100,11,111], 2]
```

#### 4.3.3 扩展运算符和concat合并数组的效果一样吗

是的，`let mergedArray = [...arr1, ...arr2]` 和 `let mergedArray = arr1.concat(arr2);` 这两种方式的效果是一样的。它们都用于合并两个数组，但是通过不同的语法实现。

**使用扩展运算符（Spread Operator）**

```javascript
let mergedArray = [...arr1, ...arr2];
```

这里使用的是ES6引入的扩展运算符`...`，它可以将一个数组展开成单独的元素。因此，当你使用`[...arr1, ...arr2]`时，实际上是将`arr1`和`arr2`中的所有元素取出来，然后放入一个新的数组`mergedArray`中。

**使用`concat`方法**

```javascript
let mergedArray = arr1.concat(arr2);
```

这里使用的是数组的`concat`方法，它用于连接两个或多个数组。该方法不会改变现有的数组，而是返回一个新数组，这个新数组包含了原始数组和其他数组或值连接在一起的结果。

**效果相同，但语法不同**

这两种方法都不会修改原始数组，而是返回一个新的数组，这个新的数组包含了原始数组`arr1`和`arr2`的所有元素。选择哪种方法主要取决于个人偏好和代码可读性。扩展运算符提供了一种更现代和简洁的语法来完成相同的任务，而`concat`方法则是一种更传统的方式。在性能方面，对于大多数应用场景，两者之间的差异微乎其微，不足以影响到选择。

#### 4.3.4 const key = [...str].sort().toString()

这段代码是在做以下几件事：

1. `[...str]`: 这是一个扩展运算符（spread operator）。它将一个字符串转化为一个字符数组。例如，字符串 `"abc"` 会被转化为 `['a', 'b', 'c']`。

2. `.sort()`: 这是一个数组方法，它会根据字母顺序对数组中的元素进行排序。比如 `['b', 'c', 'a']` 会被排序为 `['a', 'b', 'c']`。

3. `.toString()`: 这是一个数组方法，它会将数组转化为一个字符串。在这儿，它将排序后的字符数组转化为一个字符串。所有的元素会被连在一起，并且用逗号隔开。例如，`['a', 'b', 'c']` 会被转化为字符串 `"a,b,c"`。

综上，`const key = [...str].sort().toString()` 这行代码的目的就是将一个字符串的所有字符按照字母顺序排序，并用逗号连接起来，作为一个新的字符串 `key`。如果原字符串是 `"cba"`，那么 `key` 就会是 `"a,b,c"`。