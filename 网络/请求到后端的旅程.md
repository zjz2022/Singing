https://medium.com/@hnasr/the-journey-of-a-request-to-the-backend-c3de704de223

当我们向后端发送请求时，我们大多数人都关注请求的处理方面，这实际上只是最后一步。

在准备好处理请求之前，还会发生很多事情。我将其分为 6 个步骤，每个步骤理论上都可以由专用线程或进程执行。几乎所有后端、Web 服务器、代理、框架甚至数据库都必须执行所有这些步骤，并且它们都选择以不同的方式执行。

在[另一篇中等帖子](https://medium.com/@hnasr/threads-and-connections-in-backend-applications-a225eed3eddb)中，我详细探讨了步骤 1 和步骤 2，让我们在这篇文章中探讨其余部分。

![](https://miro.medium.com/v2/resize:fit:875/1*1qd9em4fTrIO5emWP-nHzg.png)

# 1-接受

请求通常在连接（TCP/QUIC）上发送，并且连接需要被后端接受。当客户端通过端口 443 连接到服务器时，服务器操作系统内核完成 3 次握手，并将连接放入侦听队列中，我们将此队列称为接受队列。后端应用程序负责在侦听器套接字上调用系统调用[accept()](https://man7.org/linux/man-pages/man2/accept.2.html)以创建表示连接的文件描述符。

如果后端接受连接的速度很慢，此步骤可能会成为瓶颈。导致大量积压的连接最终会填满队列，导致新的连接失败。

![](https://miro.medium.com/v2/resize:fit:744/1*eRCCwbut2h5O7dnIsYtM1Q.png)

当您侦听端口时，您实际上可以指定接受队列的大小，此参数称为积压。这是 NodeJS 中的示例。

为了加快连接接受速度，大多数后端都会专门使用一个线程来接受连接。如果单个线程无法跟上多个线程可以开始接受连接，但是这会产生瓶颈，因为线程在同一套接字上接受连接时会相互阻塞。

在这种情况下，[SO_REUSEPORT](https://lwn.net/Articles/542629/)选项可用于在同一端口上创建多个侦听器套接字（从而创建多个接受队列），每个线程/进程都拥有一个套接字队列。现在，这是大多数后端（如 NGINX、HAPROXY）的默认选项。

# 2-阅读

一旦连接建立，客户端就可以向后端发送请求。该请求实际上只是一系列字节，具有由所使用的协议定义的明确的开始和结束。这是客户端和后端必须就最常见的协议 HTTP 达成一致的地方。

> 请注意，即使 HTTP 协议也有具有完全不同的在线表示的版本，这会增加解析的额外成本。

客户端加密请求（如果在连接上使用 TLS）、压缩正文（如果支持请求压缩）并将数据类型（JSON/protobuff 等）序列化为在线表示形式。然后最后以网络字节顺序将原始字节写入连接。

我们感兴趣的实际上是它的后端，这些原始字节从 NIC 到达操作系统内核，并进入由内核管理的连接接收队列。

=数据包在那里设置，直到后端应用程序调用 read() 或 rcv() 系统调用，然后将数据从接收队列移动到后端进程用户空间内存。=

我们必须记住，这些是经过加密和编码的原始字节，这里没有请求，只有字节，因为我们知道我们读取的这些字节可能是 10 个请求，也可能是请求的一半。我们不知道。

读取可以在其自己的线程中完成，也可以在与接受者相同的线程中完成。

# 3-解密

现在我们在后端进程内存中拥有原始字节，并且我们知道这些字节已加密，我们调用代码链接到的 SSL 库（无论是 OpenSSL 还是其他库）并让它为我们解密内容，以便我们能够理解它。

请记住，在解密内容以查看标头和其他元数据之前，我们无法看到任何请求或知道协议的边界。这可以是 HTTP/1.1 或 HTTP/2 甚至 SSH。

解密是 CPU 密集型操作，它可以在自己的线程中完成，也可以在与读取和接受相同的线程中完成。

# 4-解析

现在我们有了明文可读字节，我们可以使用我们对约定协议的了解来解析请求，我们读取的字节块可能有完整的请求，也可能没有。据我们所知，这可能只是没有请求，而是协议系统标头（如 h2 中的 SETTINGS 帧）。

这是我们选择的库根据协议进行解析的地方，如果是 HTTP/1.1，您使用的库将读取纯文本并根据 HTTP 规范的定义查找请求的开始和结束。例如，使用内容长度或传输编码。

如果它是 HTTP/2 或 HTTP/3 库，则同样的情况适用，尽管需要做更多的工作来解析这些库，因为有更多的元数据与二进制协议相关。

请记住，解析会消耗 CPU 周期，并且会给后端带来负担，尤其是对于 h2 和 h3。一些[清晰的图表](https://www.lucidchart.com/techblog/2019/04/10/why-turning-on-http2-was-a-mistake/)在困难中被发现。

但无论如何，一旦我们解析了字节并找到了请求，我们就几乎准备好了。

协议解析可以在自己的线程中完成，也可以在与另一个线程相同的线程中完成。

# 5-解码

此步骤是需要对请求进行进一步工作的地方。使用 JSON 或 protobuf 的请求可以在此步骤中根据所选语言反序列化为对象。我们将原始字节转换为具有自己的成本和内存占用的语言结构。

> 请记住，即使在 JavaScript 中我们也不能使用 JSON 字符串，我们必须对其调用 JSON.parse，即使这是由诸如 express 之类的库自动为我们完成的，但它并不免费。

这也适用于表示以 UTF8 编码的文本的字节。如果我们知道内容是这种格式，则必须将原始字节解码为 UTF8，否则我们会遇到混乱，因为如您所知，UTF8 使用最多 4 个字节来表示某些字符。 ASCII 中的 20 个字节可能看起来与 UTF8 中的 20 个字节不同。

解码的另一个步骤是请求解压缩，但很少有可能会压缩通过 POST 发送的大型请求正文。在处理请求之前，需要解压缩主体以找出其中的内容。

# 6- 过程

最后，一旦我们理解了请求，我们就会实际处理它，无论这是否需要查询数据库、从磁盘读取、昂贵的计算。此步骤可以在同一个线程中完成，尽管建议有一个专门的工作人员进行处理，这就是工作池模式很好用的地方。

# 概括

请求在被处理之前会经历一个漫长的过程，知道这一点可以让我们后端工程师构建最合适的设计，这样每个步骤都不会成为瓶颈。

一个人可能会将所有这些步骤放在一个线程上，而另一个人可能会为每个步骤专用一个线程，另一个人可能会将步骤组合在一起。没有对错。

希望您喜欢这篇文章。查看我的[后端工程基础知识](https://backend.husseinnasser.com/)课程以了解更多信息。
