## 变量声明

### 1.1 let var const的区别

**var ES5变量声明方式**

1. 在变量未赋值时，变量undefined（为使用声明变量时也为undefined）
2. 作用域 var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用

**let ES6变量声明方式**

1. 在变量为声明前直接使用会报错
2. 作用域   let为块级作用域   通常let比var范围要小
3. let进制重复声明变量，否则会报错；var可以重复声明

**const ES6变量声明**

1. const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改常量的值
2. const实际上保证的，并不是变量的值不得改动，而时变量指向的哪个内存地址不得改动

### 1.2 先 console.log 输出变量再声明 和 如果先使用一个函数，再使用 var 声明，分别会报什么错误	

### 1.3 能不能重复多次声明变量，不是简单的变量提升

### 1.4 变量提升、函数提升有了解吗？然后给了我一个具体的例子，涉及到对一个`function`变量重新用`var`赋值，问我最后输出啥。

**变量提升和函数提升**

在 JavaScript 中，变量和函数声明会在代码执行前被“提升”到它们所在作用域的顶部。

1. **变量提升**: 使用 `var` 声明的变量会被提升，但只是声明会被提升，初始化（赋值）不会。这意味着变量会被声明为 `undefined`。
2. **函数提升**: 函数声明（不是函数表达式）会被整体提升，包括函数名和函数体。

**具体例子**

考虑以下代码：

```javascript
console.log(foo);  // 输出：[Function: foo]
foo();  // 输出："Hello from foo"

var foo = "bar";

console.log(foo);  // 输出："bar"

function foo() {
  console.log("Hello from foo");
}
```

在这个例子中，函数 `foo` 和变量 `foo` 都会被提升，但函数提升的优先级更高。所以，第一个 `console.log(foo);` 输出的是函数 `foo`，而不是 `undefined`。

当执行到 `var foo = "bar";` 时，变量 `foo` 会被重新赋值为 `"bar"`，覆盖了原来的函数。

最后一个 `console.log(foo);` 输出的是字符串 `"bar"`，因为此时的 `foo` 已经被重新赋值。

### 1.5 const a = 1; function a() {}

// 这样的代码执行之后会出现什么情况？
// 答案：const a = 1 会报错，因为函数先进行声明
// 使用了a作为函数名，之后再声明常量a浏览器会提示重复定义







js的执行上下文

为什么js存在变量提升

let和var方面的，看输入说输出，需要分析
