# 类型体操

 Easy 

 pick 

实现 TS 内置的 Pick<T, K>，但不可以使用它。

从类型 T 中选择出属性 K，构造成一个新的类型。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652238188696-977e2cec-a74d-4f6d-94a2-98a350093c0f.webp)



解:

K属性必须属于T，可以通过in关键字对K进行变量，通过T[P]取出T中有的对应值



 readonly 

不要使用内置的Readonly<T>，自己实现一个。

该 Readonly 会接收一个 泛型参数，并返回一个完全一样的类型，只是所有属性都会被 readonly 所修饰。

也就是不可以再对该对象的属性赋值。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652238311481-8ec859a6-1951-43e8-ab35-b72a600802a4.webp)



解:

可以通过in关键字对T的keyof键进行变量进行变量，通过T[P]取出T中有的对应值，并在前面加上readonly





 Tuple of Object 

传入一个元组类型，将这个元组类型转换为对象类型，这个对象类型的键/值都是从元组中遍历出来。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652238467871-f388c169-b2d2-4534-8a84-46a6a6bc16ce.webp)



解:

通过T[number]可以获取元组的类型项，通过in来进行遍历





 First of Array 

实现一个通用First<T>，它接受一个数组T并返回它的第一个元素的类型。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652238597489-0472aa24-6541-4ffd-af6a-5d585b62e950.webp)



解:

infer是推断，相当于设x，推断出first的值占位，满足条件的则返回





 Length of Tuple 

创建一个通用的Length，接受一个readonly的数组，返回这个数组的长度。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652238712520-d4fa4f76-1ae0-4751-908c-4552d04ad72a.webp)



解:

T["length"]关键字可以返回元组的长度





 Exclude 

实现内置的Exclude <T, U>类型，但不能直接使用它本身。

从联合类型T中排除U的类型成员，来构造一个新的类型。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652238994872-c34de4fc-1b90-4f94-a38b-2cc2ea9b2f94.webp)



解:

利用了extends的分布式原理，中的每一个元素都会判断是属于U，不属于的话则返回相应元素





 Awaited 

假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 Promise 中的 T 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652239762683-da7e4fe9-e3d1-44d4-9c32-40b40494999b.webp)



解:

嵌套三元运算，使用infer进行推断类型，这里要注意如果X还是promise类型则递归实现





 IF 

未完成





 Concat 

在类型系统里实现 JavaScript 内置的 Array.concat 方法，这个类型接受两个参数，返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652239662525-5a7c46b3-dd7c-4acd-91b9-f88194158ea8.webp)



解:

通过拓展运算符解构数组





 Includes 

在类型系统里实现 JavaScript 的 Array.includes 方法，这个类型接受两个参数，返回的类型要么是 true 要么是 false。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652239875176-05c10ba2-7bb1-44e6-8373-ff80ca8476e5.webp)



解:

通过T[number]遍历元组，然后进行extend判断





 Push 

在类型系统里实现通用的 Array.push

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652239946876-de657426-6553-4fcc-9005-4e5cef6e843c.webp)



解:

通过拓展运算符解构数组





 Unshift 

实现类型版本的 Array.unshift

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652240137894-9185fd15-aff2-4a0b-baac-f46b7296a3b5.webp)



解:

通过拓展运算符解构数组





 Parameters 

实现内置的 Parameters 类型，而不是直接使用它

把函数的键取出通过数组的方式返回

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652240723536-1941b8f8-6298-4b98-8e0e-357011e03df0.webp)



解:

通过infer推断+rest参数的形式获取到形参，然后返回





 Medium 

 1.getReturnType 

不使用 ReturnType 实现 TypeScript 的 ReturnType<T> 泛型

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652241721714-2a2d1e54-8188-4485-ba1b-1743002f88d8.webp)



解:

因为不确定具体返回的类型是哪个，所以使用infer进行推断





 2.Omit(不熟) 

不使用 Omit 实现 TypeScript 的 Omit<T, K> 泛型。

Omit 会创建一个省略 K 中字段的 T 对象。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652242116077-a5de40f9-49ed-4a9f-bd25-7cd9e345f01c.webp)



解:

使用(Key Remapping via as)来对键进行更多的约束，同时通过条件类型来过滤键



 3.Readonly 

实现一个通用MyReadonly2<T, K>，它带有两种类型的参数T和K。

K指定应设置为Readonly的T的属性集。如果未提供K，则应使所有属性都变为只读，就像普通的Readonly<T>一样。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652253127362-b39c5f1c-dda4-45ef-bdee-d295372a76f1.webp)



解:

使用(Key Remapping via as)来对键进行更多的约束，判断其是否属于U，同时通过条件类型来过滤键,通过&实现并集，满足U情况的前面都会加上readonly，不在U中的则不添加





 4.Deep Readonly 

实现一个通用的DeepReadonly<T>，它将对象的每个参数及其子对象递归地设为只读。

您可以假设在此挑战中我们仅处理对象。数组，函数，类等都无需考虑。但是，您仍然可以通过覆盖尽可能多的不同案例来挑战自己。

例如

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652253211241-a1adfa1e-e2a1-4b5d-a7f7-a13bcc77694b.webp)



解:

这题要注意判断对象中嵌套对象的情况，如果值还是个对象就递归调用





 5.Tuple of Union 

实现泛型TupleToUnion<T>，它返回元组所有值的合集。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652253822141-8b5d141f-53b7-4a6d-a240-af9a66eb3be1.webp)



解:

通过T[number]可以获得元组的合集



 6.Chainable Options 

  

 7.Last of Array 

实现一个通用Last<T>，它接受一个数组T并返回其最后一个元素的类型。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652424691111-ba18899a-a47d-4ee5-8f59-cf43804a48cd.webp)



解:

使用推断，将最后一个参数推断后不返回





 8.Pop 

实现一个通用Pop<T>，它接受一个数组T并返回一个没有最后一个元素的数组。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652424504207-dffd29ce-cf17-49c0-a173-051bcd9e481a.webp)



解:

使用推断，将最后一个参数推断后不返回





 9.PromiseAll 

键入函数PromiseAll，它接受PromiseLike对象数组，返回值应为Promise<T>，其中T是解析的结果数组。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652602269303-52abdd57-3bbc-47cb-b996-952a91299b09.webp)



解:

注意接收到的参数是一个可读的参数，keyof T是将索引取出





 10.TypeLookUp 

有时，您可能希望根据其属性在并集中查找类型。

在此挑战中，我们想通过在联合Cat | Dog中搜索公共type字段来获取相应的类型。换句话说，在以下示例中，我们期望LookUp<Dog | Cat, 'dog'>获得Dog，LookUp<Dog | Cat, 'cat'>获得Cat。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652584302407-ce939a43-5f91-48bf-8fce-40984386ba48.webp)



解:

通过extends分布式比较的原理，巧妙构造一个{}这样只要T中含有这个对象就会返回相应的类型





 11.TrimLeft 

实现 TrimLeft<T> ，它接收确定的字符串类型并返回一个新的字符串，其中新返回的字符串删除了原字符串开头的空白字符串。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652587238601-f0c0a52a-a8fb-4942-8400-93368bfe486a.webp)



解:

字符串满足推断格式，但不确定左边有多少个空格，所以需要使用递归调用，如果左边不存在空格就返回S





 12.Trim 

实现Trim<T>，它是一个字符串类型，并返回一个新字符串，其中两端的空白符都已被删除。



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652587490097-615a560e-05cd-43b7-a559-e3a018a4e68b.webp)



解:

TrimLeft和TrimRight的结合就是Trim了







 13.Capitalize  

实现 Capitalize<T> 它将字符串的第一个字母转换为大写，其余字母保持原样。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652841010266-9ed3c7eb-a4a2-4819-814b-856435398efe.webp)



使用uppercase来进行大写的转换，要注意""是一个特殊情况，要过滤掉







 14.Replace 

实现 Replace<S, From, To> 将字符串 S 中的第一个子字符串 From 替换为 To 。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652670167745-c9dc63a3-6e10-4998-96c9-4cc9054808f4.webp)



解:

使用推断，将推断前的From置换成To，From前面后面的字符不改变





 15.ReplaceAll 

实现 ReplaceAll<S, From, To> 将一个字符串 S 中的所有子字符串 From 替换为 To。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652672064348-54df4147-9993-4ba4-bed9-286cc3194e02.webp)



解:

这道题要考虑的东西就比较多了，首先如果From是''或和To一样的是直接跳出递归的，然后是匹配过程，由于已经匹配后的东西不能再次匹配，所以是将右边进行递归

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652672279021-8da69734-f983-45ad-a374-8cbed5d7f783.webp)



这里的bo变为b后又构造出了bo，此时这个bo是不能再被匹配上的





 16.appendArgument 

实现一个泛型 AppendArgument<Fn, A>，对于给定的函数类型 Fn，以及一个任意类型 A，返回一个新的函数 G。G 拥有 Fn 的所有参数并在末尾追加类型为 A 的参数。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652925091289-5f8cf143-3632-41f2-89d2-fc8a66197cdf.webp)



解:

通过推断的方式提取参数，然后通过剩余参数进行增加参数





 18.Length of String 

实现求出string长度的类型

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1653359166676-4db2690c-e829-4681-b080-f06097ba50e0.webp)



解:通过数组的["length"]属性，递归构造数组，一次增加1





 24.KebabCase 

FooBarBaz -> foo-bar-baz

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652845680888-7f0f50b6-0feb-4320-b306-b13ebd3187bb.webp)



解：

这道题有点难度，Uncapitalize的作用是将第一个字符转换成小写，判断是否满足条件，递归循环

过程

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652845827220-07aa2829-6a87-4c26-9a74-46e209ac1092.webp)







 28.isNever 

判断一个类型是否是never

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1653800794239-fa56275f-d918-46ff-9118-ad6e0fcbfb39.webp)



解:

●never 在条件类型中也比较特殊，如果条件类型左边是类型参数，并且传入的是 never，那么直接返回 never：

●所以，要判断 never 类型，就不能直接 T extends number，可以这样写：

  

 28.isUnion 

判断一个类型是否是联合类型

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1653636871066-8ca09f1b-01f9-4420-a0da-a81a24c59045.webp)



解:

●A extends A 这种写法是为了触发分布式条件类型，让每个类型单独传入处理的，没别的意义。

●A extends A 和 [A] extends [A] 是不同的处理，前者是单个类型和整个类型做判断，后者两边都是整个联合类型，因为只有 extends 左边直接是类型参数才会触发分布式条件类型。







 36.StartWith 

实现StartWith，判断是否是以某个前缀开头

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652668707780-fe8dde4a-ed86-45c4-84a3-99c3d78aa73f.webp)



解:

模糊匹配，开头用U，后边用string





 37.EndWith 

实现EndWith，判断是否是以某个后缀

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652668885158-7bac3912-7dff-4a04-9a8f-be3823970221.webp)



解:

模糊匹配，后缀用U，开头用string







 43.Shift 

实现Shift

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652667443562-c19088c9-03e7-41e8-b68b-705a76c2060a.webp)



解:

使用推断，类似于pop的操作







 45.Reverse  

Implement the type version of Array.reverse

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652926431133-b1a7beb3-3d31-4d7c-b02e-0e4c4c9b761c.webp)



解:通过递归的方式逐渐递归，通过推断活动剩余的参数







 48.BEM 

bem 是 css 命名规范，用 block__element--modifier 的形式来描述某个区块下面的某个元素的某个状态的样式。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1653637755638-58b6218a-27a9-4e69-8fa9-2c6efd9200b7.webp)



解:

使用联合类型不用递归遍历了，因为联合类型遇到字符串也是会单独每个元素单独传入做处理，还要对空值进行一个判断







 51.Fibonacci 

实现斐波那契数列

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1653363099498-ce9a5028-5ae6-4243-9db0-bd38bebe8004.webp)



解:

类型参数 PrevArr 是代表之前的累加值的数组。类型参数 CurrentArr 是代表当前数值的数组。

类型参数 IndexArr 用于记录 index，每次递归加一，默认值是 []，代表从 0 开始。

类型参数 Num 代表求数列的第几个数。

判断当前 index 也就是 IndexArr['length'] 是否到了 Num，到了就返回当前的数值 CurrentArr['length']。







 53.Greater Than 

实现一个类型可以用来比较数字的大小

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1653359746302-1208801f-43ff-4627-b087-f4ee1555e510.webp)



解:

Num1 > Num2才会返回false，所以可以先判断是否相等，若不相等判断Num1和Num2哪个先和数组长度相等，先相等的肯定是小的







 54.Zip 

实现任意数组的参数合并

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652673497145-fd26a10f-29ce-4efa-9aa1-0904e6bf5097.webp)



解:

合并任意个数组参数，首先要用到递归了，每次提取 One 和 Other 的第一个元素 OneFirst、OtherFirst，剩余的放到 OneRest、OtherRest 里。

用 OneFirst、OtherFirst 构造成新的元组的一个元素，剩余元素继续递归处理 OneRest、OtherRest。

 55.isTuple 

实现一个类型用来判断是否为tuple类型

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1653969319618-3bb0f33b-2771-43c0-a1ba-2cef4b3bd42b.webp)



解:

根据下面这个特性来实现的

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1653969401667-c6fd8620-ef55-48c1-904d-afebede8890e.webp)



类型参数 T 是要判断的类型。首先判断 T 是否是数组类型，如果不是则返回 false。如果是继续判断 length 属性是否是 number。如果是数组并且 length 不是 number 类型，那就代表 T 是元组。





 58.TrimRight 

实现 TrimRight<T> ，它接收确定的字符串类型并返回一个新的字符串，其中新返回的字符串删除了原字符串开头的空白字符串。

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1652587571800-c7ed6a8a-2961-4a50-8ab5-60f6b7e610d3.webp)



解:

字符串满足推断格式，但不确定右边有多少个空格，所以需要使用递归调用，如果右边不存在空格就返回S