- 数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流

在双向绑定的建立过程中，有一个理想的结果：我们可以轻易的知道数据与 DOM 节点的对应关系，那么通过数据驱动 UI 的形式来开发代码将会变得非常容易。双向绑定采取的措施是递归遍历监听所有数据，依次建立与对应 UI 的绑定关系。这种解决方案所花费的成本主要体现在对数据的处理上，他面临两个问题：
一是数据的变化需要监听，但是某些数据类型的监听在实现上有难度，比如 forceUpdate，比如大量的 Watcher，还有性能损耗更严重的 Deep Watcher。另一个问题就是数据的层级与变化问题，数据层级越深，我们想要深度监听，就得使用递归的方式。当数据发生变化时，部分数据与 UI 的绑定关系需要重新建立「在 vue 中，就是重复依赖收集的过程」，如果数据量过大，或者数据变化频繁，就会有性能风险。
react 把所有的精力都放在了 UI 层。使用我们现在熟知的 diff 算法，当数据发生变化时，react 会创建一个新的虚拟DOM树，与之前的树做对比，找出需要改变的元素。
从总体思路上来说，vue 的主要压力在于处理数据，react 的主要压力在于处理 UI。react 不建立数据与 UI 的对应关系，那么也就意味着另外一个压力的产生，那就是当数据发生变化时，react 并不知道哪一个 UI 发生了变化，于此同时 react 为了保持自己对于 Js 的弱侵入性，也没有在 setState 上进行任何魔改，例如绑定当前上下文从而得知具体哪个组件的 state 发生了变化。[如果进行了这个魔改，diff 的压力会小一些]。因此，每一次的 state 变化，都是整棵 DOM 树的 diff。
Vue2中借鉴了diff算法，vue3中使用Proxy 能够监听数组的变化，能够监听删除对象字段的变化... 于是 Vue3 的底层实现，在数据侧的代码会简洁很多，并且与此同时，Vue 的后续版本，也可以彻底放弃虚拟 DOM 来进一步提高自己的运行性能。但是，依然有一个问题没有解决，那就是深度监听仍然需要递归。当数据量很大的时候，依赖追踪的压力也会逐渐变大，当你的项目变得越来越大，全局数据变得越来越复杂，层级越来越深，他的性能压力也会逐渐变大。因此这也是目前大多数大厂中后台采用React的原因，而面向用户则采用Vue的原因。