## 版本控制

### 2.1 git

**0 版本控制系统根据类别可以分成：**

- 本地版本控制系统：简单，但不支持远程操作，不适合多人开发。
- 集中式版本控制系统(SVN|CVS)：适合多人开发，代码集中管理(文件管理，可以加锁)，但是单点故障，必须联网，无法单机工作。
- 分布式版本控制系统

**1 版本控制：**一种在开发过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。

**2 常用命令：**

- add 放入暂存区
- rm --cached 删除暂存区的xxx
- commit- v 提交时显示所有diff信息，提交到版本库 -m 提示信息
- branch <新分支名> 基于当前分支，新建一个分支
- checkout 切换到本地某个分支
- push 上传所有标签
- merge：合并分支会新增一个merge commit，然后将两个分支的历史联系起来。其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂。
- rebase会将整个分支移动到另一个分支上，进行多个分支的合并。主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 git merge所需的不必要的合并提交
- pull <远程仓库名> <远程分支名>:<本地分支名> 拉取远程仓库的分支与本地当前分支合并(可能产生版本冲突) git pull = git fetch + git merge
- fetch 将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中，通过--depth 限制拉取的历史提交记录。
- reset --hard  HEAD 回退到上一个(^回退几次或利用 SHA 哈希)，soft 保留工作区与暂存区，hard 不保留。
- revert 将回退记录生成为一次新的提交
- stash可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上。默认情况下，会缓存下列状态的文件：添加到暂存区的修改，Git跟踪的但并未添加到暂存区的修改。但以下状态的文件不会缓存：在工作目录中新的文件，被忽略的文件。（应用场景：当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情）

**3 版本冲突**

一般情况下，出现分支的场景有如下：多个分支代码合并到一个分支时、多个分支向同一个远端分支推送。

具体情况就是，多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称。

如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可。

应用在命令中，就是`push`、`pull`、`stash`、`rebase`等命令下都有可能产生冲突情况，从本质上来讲，都是`merge`和`patch`（应用补丁）时产生冲突

`git`用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容：

将冲突的内容进行更改，对每个文件使用 `git add` 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，`Git`就会将它们标记为冲突已解决然后再提交。

**4 团队协作**

```bsh
git remote add origin https://github.com  // 新建一个项目
git push origin master //提交当前版本
git branch -a //显示所有分支版本
```

如果改的不是同一个文件，依旧会产生版本冲突，但是需要先pull在提交。

**5 actions**

**6  鉴权**

**7 工作流  workflow**

​		项目开发中，多人协作，分支很多，虽然各自在分支上互不干扰，但是我们总归需要把分支合并到一起，而且真实项目中涉及到很多问题，例如版本迭代，版本发布，bug 修复等，为了更好的管理代码，需要制定一个工作流程，这就是我们说的工作流，也有人叫它分支管理策略。

​		目前使用度最高的工作流前三名（排名不分先后哈）分别是以下三种：Git Flow、GitHub Flow和GitLab Flow		其中 Git Flow 出现的最早，GitHub Flow 在 Git Flow 的基础上，做了一些优化，适用于持续版本的发布，而 GitLab Flow 出现的时间比较晚，所以综合前面两种工作流的优点，制定而成的一个工作流。

​		**Git Flow**

​		Git Flow 的分支结构很特别，按功能来说，可以分支为5种分支，从5 种分支的生命时间上，又可以分别归类为长期分支和暂时分支，或者更贴切描述为，主要分支和协助分支。

主要分支：在采用 Git Flow 工作流的项目中，代码的中央仓库会一直存在以下两个长期分支：

- master
- develop

其中 origin/master 分支上的最新代码永远是版本发布状态。origin／develop 分支则是最新的开发进度。

当 develop 上的代码达到一个稳定的状态，可以发布版本的时候，develop上这些修改会以某种特别方式被合并到 master 分支上，然后标记上对应的版本标签。

协助分支：除了主要分支，Git Flow 的开发模式还需要一系列的协助分支，来帮助更好的功能的并行开发，简化功能开发和问题修复。是的，就是下面的三类分支。这类分支是暂时分支非常无私奉献，在需要它们的时候，迫切地创建，用完它们的时候，又挥挥衣袖地彻底消失。协助分支分为以下几类：

- Feature Branch
- Release Branch
- Hotfix Branch

Feature 分支用来做分模块功能开发，命名看开发者喜好，不要和其他类型的分支命名弄混淆就好，举个坏例子，命名为 master 就是一个非常不妥当的举动。模块完成之后，会合并到 develop 分支，然后删除自己。

Release 分支用来做版本发布的预发布分支，建议命名为 release-xxx。例如在软件 1.0.0 版本的功能全部开发完成，提交测试之后，从 develop 检出release-1.0.0 ,测试中出现的小问题，在 release 分支进行修改提交，测试完毕准备发布的时候，代码会合并到 master 和 develop，master 分支合并后会打上对应版本标签 v1.0.0, 合并后删除自己，这样做的好处是，在测试的时候，不影响下一个版本功能并行开发。

Hotfix 分支是用来做线上的紧急 bug 修复的分支,建议命名为 hotfix-xxx。当线上某个版本出现了问题，将检出对应版本的代码，创建 Hotfix 分支，问题修复后，合并回 master 和 develop ，然后删除自己。这里注意，合并到 master 的时候，也要打上修复后的版本标签。

```
优势
在项目周期之内，该工作流保证任何时刻两个主要分支都是处于纯净状态的
由于遵循系统化的模式，因此分支命名容易理解
大多数Git工具都支持该工作流的扩展工具
当项目中需要同时维护多个生产版本时，该工作流模式非常理想
缺陷
Git 的历史记录将变得异常混乱，可读性很差
master / develop 分支的割裂使CI/CD流程变得更加困难
当项目维护单一生产环境版本时，该工作流则不适用
```

​		**GitHub Flow**GitHub 工作流是一个轻型的工作流，它是GitHub 在2011年创建，其工作流遵循以下6个原则：

- 任何时刻的master分支代码都是可以用来部署的
- 任何新变更都需要从master派生出一个分支，并且为其起一个描述新变更内容的名字：比如 new-oauth2-scopes
- 在本地提交该新分支变更，并且应经常性的向服务器端该同名分支推送变更
- 当你需要帮助、反馈，或认为新分支可以合并的时候，新建一个pull request
- 只有在其他人review通过之后，新分支才允许合并到 master 分支
- 一旦新分支被合并推送至master分支，master分支应当立即进行部署

```
优势
该工作流对于CI/CD流程友好
是Git工作流的一种简版替换
当项目维护单一生产环境版本时，该工作流适用
缺陷
生产环境对应的代码极易处于不稳定状态
对于依赖发布计划的项目无法充分支持
该工作流并不涉及关于部署，环境，发布和问题等方面的解决方案
当项目维护多生产环境版本时，该工作流不适用
```

- rebasehttps://blog.csdn.net/weixin_42310154/article/details/119004977
- https://blog.csdn.net/qq_32452623/article/details/78905181
- https://zhuanlan.zhihu.com/p/434078984

### 2.2 SourceTree