## 一些方法

### 3.1 Keep-alive

​	keep-alive作为一种vue的内置组件，主要作用是缓存组件状态。当需要组件的切换时，不用重新渲染组件，避免多次渲染，就可以使用keep-alive包裹组件。

```vue
<!-- 基本 --> 
<keep-alive> 
    <component :is="view"></component> 
</keep-alive> 
<!-- 多个条件判断的子组件 -->
<keep-alive> 
    <comp-a v-if="a > 1"></comp-a> 
    <comp-b v-else></comp-b> 
</keep-alive>
<!-- 和 `<transition>` 一起使用 -->
<transition> 
    <keep-alive> 
        <component :is="view"></component> 
    </keep-alive> 
</transition>
```

​		`keep-alive`是一个组件，这个组件中有三个属性，分别是`include`、`exclude`、`max`，在`created`中创建缓存列表和缓存组件的key列表，销毁的时候会做一个循环销毁清空所有的缓存和key。当`mounted`时会监控`include`和`include`属性，进行组件的缓存处理。按需缓存，keep-alive组件如果设置了 include ，就只有和 include 匹配的组件会被缓存。



​		该组件如果缓存过，就直接拿到组件实例，如果没有就存进当前的`vnode`中，和key做一个对应关系。

在 keep-alive 的源码定义中，它作为一个组件有自己的 render() 阶段会缓存 vnode 和组件名称 key 等操作。

首先会判断是否存在缓存，如果存在，则直接从缓存中获取组件的实例，并进行缓存优化处理（这里面有一个算法叫`LRU`，如果有key就不停的取，如果超限了就采用`LRU`进行删除最近最久未使用的，从前面删除，`LRU`就是将当前使用的往数组的后面移，在最前面的就是最久未使用的）。

​	如果发生变化会动态的添加和删除缓存，渲染的时候会去拿`默认插槽`，只缓存第一个组件，根据组件的名字判断是否在缓存中，如果在就缓存，不在就return掉，不在就直接return掉。缓存的时候，如果组件没有key，就自己通过组件的标签，key和cid拼接一个key。

```js
var KeepAlive = {
  ...
  props: {
    include: patternTypes,  // 名称匹配的组件会被缓存，对外暴露 include 属性 api
    exclude: patternTypes,  // 名称匹配的组件不会被缓存，对外暴露 exclude 属性 api
    max: [String, Number]  // 可以缓存的组件最大个数，对外暴露 max 属性 api
  },
```

注意：

```
iframe 标签承载了一个单独的嵌入的窗口，它有自己的 document 和 window (浏览器会检查 iframe 是否具有相同的源)
```

​		iframe中keep-alive机制失效原因：iframe页里的内容并不属于节点的信息，所以使用keep-alive依然会重新渲染iframe内的内容。而且iframe每一次渲染就相当于打开一个新的网页窗口，即使把节点保存下来，在渲染时iframe页还是刷新的。

解决策略：

1. 切换不含iframe的界面时使用vue路由，在切换含iframe页的界面时利用v-show来控制显示隐藏，使iframe的节点不被删除，以此来防止界面节点被重新更新，从而达到保存iframe节点数据的效果
2. 使用不带iframe的组件正常使用keep-alive，带iframe的组件开始时隐藏，切换到带iframe的组件时，隐藏其他不带iframe的组件，显示带iframe的组件，通过v-if将iframe的显示做成懒加载形式的，只有在用户进入相应的页面时才触发渲染，在渲染完毕后再通过v-show去控制界面在切换时的显示与隐藏。

https://juejin.cn/post/7133038641370595365

https://juejin.cn/post/7037321886019092510#heading-6

### 3.2 NextTick

​		定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

​		nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。

​		将传入的回调函数包装成异步任务，异步任务又分微任务和宏任务，为了尽快执行所以优先选择微任务；Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。

**DOM树更新是同步的**

每一轮事件循环的最后会进行一次页面渲染，并且从上面我们知道渲染过程也是个宏任务，这里可能会有个误区，那就是DOM tree的修改是同步的，只有渲染过程是异步的，也就是说我们在修改完DOM后能够立即获取到更新的DOM。

**为什么Vue却需要借用$nextTick来处理**

因为Vue处于性能考虑，Vue会将用户同步修改的多次数据缓存起来，等同步代码执行完，说明这一次的数据修改就结束了，然后才会去更新对应DOM，一方面可以省去不必要的DOM操作，比如同时修改一个数据多次，只需要关心最后一次就好了，另一方面可以将DOM操作聚集，提升render性能。

**为什么优先使用微任务？**

因为微任务一定比宏任务优先执行，如果nextTick是微任务，它会在当前同步任务执行完立即执行所有的微任务，也就是修改DOM的操作也会在当前tick内执行，等本轮tick任务全部执行完成，才是开始执行UI rendering。如果nextTick是宏任务，它会被推进宏任务队列，并且在本轮tick执行完之后的某一轮执行，注意，它并不一定是下一轮，因为你不确定宏任务队列中它之前还有所少个宏任务在等待着。所以为了能够尽快更新DOM，Vue中优先采用的是微任务，并且在Vue3中，它没有了兼容判断，直接使用的是promise.then微任务，不再考虑宏任务了。

​		Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。

​		当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它。

​		Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。		当设置 vm.someData = 'new value'，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。

参考：

- vue.nextTick()方法的使用详解（简单明了）https://blog.csdn.net/zhouzuoluo/article/details/84752280
- https://juejin.cn/post/7089980191329484830#heading-10

### 3.3 插槽slot

1.插槽是使用在子组件中的。

2.插槽是为了将父组件中的子组件模板数据正常显示

```
//home.vue
<test>
     Hello Word
</test>
//test.vue
<a href="#">
	 <slot></slot>
</a>
//当组件渲染的时候，<slot></slot>会被替换为Hello Word
```

3 插槽内可以包含普通文本，也可以包含任何模板代码，包括HTML

```
//home.vue
<test>
	//插槽可以获取到home组件里的内容
	Hello {{enhavo}}
</test>

data(){
	return{
		enhavo:'word'
	}
}
//home.vue
//这里是获取不到name的，因为这个值是传给<test>的
<test name='you'>
    Hello {{name}}
</test>
```

4 插槽跟模板其他地方一样都可以访问相同的实例属性(也就是相同的"作用域")，而不能访问<test>的作用域。原因是父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。

**具名插槽**

​		有时候我们一个组件里需要**多个插槽**，对于这样的情况，`<slot>`元素有一个特殊的特性：`name` ，这个特性可以用来**定义额外的插槽**

​		如果一个`<slot>`不带`name`属性的话，那么它的`name`默认为`default`。在向具名插槽提供内容的时候，我们可以在`<template>`元素上使用`v-slot`指令，并以参数的形式提供其名称

具名插槽的缩写(2.6.0新增)

​		跟 `v-on` 和 `v-bind` 一样，`v-slot` 也有缩写，即把参数之前的所有内容 `(v-slot:)` 替换为字符 `#`。例如 `v-slot:header` 可以被重写为 `#header`：

**作用域插槽**

我们可以在父组件中使用slot-scope 特性从子组件获取数据， 前提是需要在子组件中使用:data=data  先传递data 的数据。

**动态插槽**

动态指令参数也可以用在v-slot上，来定义动态的插槽名：

```
<base-layout>
  <template v-slot:[dynamicSlotName]>
    ...
  </template>
</base-layout>
```

### 3.4 lazyload

核心逻辑是： 图片在视图范围内，就显示，否则只显示加载图标。而图片在不在视图范围内，是动态变化的，比如滚动的时候，图片就可能从视图外到视图内。

```
import VueLazyload from 'vue-lazyload'

Vue.use(VueLazyload,{
  preLoad: 1.3,
  loading: 'dist/loading.gif',
})

// 使用的时候，直接在想懒加载的img上，加个指令就好了
// <img v-lazy="img.src">
```

**原理：**

​		通过getBoundingClientRect可以知道,元素相对于视图窗口的**左上角**的距离。

```js
Element.getBoundingClientRect() //方法返回一个 DOMRect 对象，其提供了元素的大小及其相对于视口的位置。
```

​		**元素在不在视图内，其实本质上就是判断：****`top > windowHeight`**。`top`越大，元素离地址栏就会越来越远，当距离**大于**`windowHeight`，就不在视图范围内。

```js
const windowHeight = window.innerHeight
// 元素离地址栏的近似距离
const {top} = ele.getBoundingClientRect()
const isInView = top<windowHeight
```

1. vue-lazyload是通过指令的方式实现的，定义的指令是v-lazy指令
2. 指令被bind时会创建一个listener，并将其添加到listener queue里面， 并且搜索target dom节点，为其注册dom事件(如scroll事件)
3. 上面的dom事件回调中，会遍历 listener queue里的listener，判断此listener绑定的dom是否处于页面中perload的位置，如果处于则加载异步加载当前图片的资源
4. 同时listener会在当前图片加载的过程的loading，loaded，error三种状态触发当前dom渲染的函数，分别渲染三种状态下dom的内容