# JavaScript — ECMAScript® 2024 (ES15) 的新增功能 — 深度指南

https://medium.com/@yourfuse/javascript-whats-new-with-ecmascript-2024-es15-ef056d2f4bf1

***实时文章 — 最后更新时间：2024 年 2 月 7 日。\***

发现编程语言的新功能就像假期或生日一样——这是一个充满期待和探索新礼物的快乐的激动人心的时刻。借助**ES2024** ®提出的功能，开发人员即将推出各种增强功能，这些增强功能有望使 JavaScript 编码更加高效、可读和健壮。从顶层的直观语法`await`到管道运算符的表达能力，再到不可变记录和元组的可靠性，每一个新功能都像是精心挑选的礼物，旨在丰富 JavaScript 生态系统，为开发者提供更多可用的工具。处理。

根据[ECMAScript 2024 国际化 API 规范](https://tc39.es/ecma402/)（ECMA-402 第 11 版），ES2024 中计划包含一些功能。

请记住，其中一些仍然是“提案”，因此事情可能会有所调整，但幸运的是，本文将根据批准的更改进行调整！

无需再费周折…

# 格式正确的 Unicode 字符串

此功能旨在改进 JavaScript 处理 Unicode 字符串的方式。 Unicode 字符串对于表示来自不同语言和符号的各种字符至关重要。此更新将确保在不同的 JavaScript 环境中一致且准确地处理这些字符串。

```JS
const SampleStrings = [ 
  // 单独代理项的示例
  "igor\uD800" , // 前导代理项
  "igor\uD800komolov" , // 前导代理项后跟文本
  "\uDC00yourfuse" ,     // 尾随代理项
  "your\uDC00fuse" ,     //尾随代理项后跟文本
  
  // 格式良好的示例
  "yourFuse" ,        // 不带代理项的常规字符串
  "emoji\uD83D\uDE00" , // 具有完整代理项对的字符串 (emoji)
 ];

样本字符串。forEach ( str => { 
  console .log ( `处理后的字符串: ${str.toWellFormed()} ` ); 
}); 

// 预期输出: 
// "已处理的字符串: igor�" 
// "已处理的字符串: igor�komolov" 
// "已处理的字符串: �yourfuse" 
// "已处理的字符串: your�fuse" 
// "已处理的字符串: yourFuse " 
// "已处理的字符串：emoji😀"
```

在上面的示例中，该`toWellFormed()`方法应用于字符串数组，包括一些带有单独代理的字符串和一些格式良好的字符串。该方法通过用替换字符替换无效序列，将具有单独[代理](https://medium.com/@yourfuse/what-is-a-surrogate-22d85b46025b)项的字符串转换为格式良好的 Unicode 字符串，同时保持格式良好的字符串不变。

```JS
const ProblemURL = "https://yourfuse.com/query=\uDC00data" ;

尝试{ 
  encodeURI（有问题的URL）；
} catch (e) {
  控制台. log ( '错误：'，e.消息); // 预期: URIError: URI malformed
 } 

// 使用 toWellFormed() 来防止错误
console . log ( '格式良好的 URI:' , encodeURI ( problematicURL.toWellFormed ())); // 预期输出：“https://yourfuse.com/query=%EF%BF%BDdata”
```

- 该变量`problematicURL`包含一个带有单独尾随代理项 ( ) 的 URL `\uDC00`。
- 由于 Unicode 字符串格式错误，尝试对此 URL 进行编码`encodeURI()`会引发 URIError。
- 通过应用`toWellFormed()`，单独的代理项将替换为 Unicode 替换字符（`U+FFFD`，编码为`%EF%BF%BD`），从而可以`encodeURI()`无错误地处理它。

# 原子等待同步

此添加针对并发操作，特别是在共享内存上下文中。它提供了一种同步机制，对于确保数据完整性和防止多线程操作中的竞争条件至关重要。例如，waitSync 可用于同步多个工作人员之间对共享缓冲区的访问。

由于我们还没有示例，因为文档仍在充实中，所以我无法向您展示它将如何实现。不过，我们可以根据现有的 Atomics 方法进行猜测。开始…

```JS
// 假设sharedArray是一个SharedArrayBuffer 
const sharedArray = new  Int32Array ( new  SharedArrayBuffer ( 1024 )); 

function  PerformSynchronizedOperation ( index, value ) { 
    // waitSync 方法将阻塞执行，直到满足特定条件。
    // 例如，它可以等到指定索引处的值不再等于 0。
    Atomics . waitSync (sharedArray, 索引, 0 ); 

    // 对共享内存执行操作
    sharedArray[index] = value; 

    // 通知其他线程或工作线程索引处的值已更新
    Atomics .通知（sharedArray，索引，1）；
} 

// 在 Web Worker 或另一个线程中
PerformSynchronizedOperation ( 0 , 123 );
```

# 具有设置符号+字符串属性的 RegExp v 标志

JavaScript 中正则表达式的这种改进允许更复杂的模式匹配和字符串操作。 “v”标志和设置符号可实现更精确和更具表现力的正则表达式模式。例如，您可以使用此功能来匹配具有特定 Unicode 属性的一组字符。

```JS
// 差/减
[A--B] 

// 交集
[A&&B] 

// 嵌套字符类
[A--[ 0 - 9 ]]
```

`A`可以`B`将其视为字符类（例如`[a-z]`）或属性转义的占位符。[该提案的说明性示例和常见问题解答](https://github.com/tc39/proposal-regexp-v-flag#illustrative-examples)。

# 顶级等待

这种“Just Do It”功能允许在异步函数之外使用await关键字，从而使异步代码更易于编写和阅读。例如，您可以直接在模块的顶层等待承诺，从而简化导入模块或异步获取数据的代码。

```JS
// 与顶级await 
const data = wait  fetchData ();
安慰。日志（数据）；
```

当然，确实可以为繁重的异步/等待结构带来一些新鲜空气！

# 管道操作员

管道运算符 (|>) 通过多个函数调用提高了代码的可读性。它允许使用函数式语法，其中表达式的结果作为参数传递给下一个函数。例如，您可以将嵌套函数调用重构为清晰的操作序列：

```JS
// 没有管道运算符
const计算值 = Math . ceil ( Math . pow ( Math . max ( 0 , - 10 ), 1 / 3 )); 

// 使用管道运算符
const returnedValue = - 10
   |> ( n =>  Math . max ( 0 , n)) // 替换 Math.max
   |> ( n =>  Math . pow (n, 1 / 3 )) //替换 Math.pow
   |> Math。天花板; // 使用 Math.ceil
```

在这个例子中：

- 该`Math.max`函数确保数字不为负数。
- 该`Math.pow`函数计算立方根（1/3 次方）。
- 该`Math.ceil`函数将数字向上舍入到最接近的整数。

管道运算符 ( `|>`) 简化了这些操作的链接，使代码更具可读性。

现在，下面的示例演示了管道运算符对于数据转换的有用性：

```JS
// 管道运算符允许以清晰、简洁的方式应用一系列函数，从而简化了复杂的数据操作。

常量数字 = [ 10 , 20 , 30 , 40 , 50 ]; 

constprocessedNumbers = 数字
  |> ( _ = > _.map ( n => n / 2 )) // 将每个数字减半  |> ( _ => _.filter ( n => n > 10 )) ; // 过滤掉小于或等于10的数字console .日志（已处理的数字）；// [15, 20, 25]
```

在这个例子中：

- 该`map`函数将数组中的每个数字减半。
- 然后，该`filter`函数会删除所有 10 或更少的数字。
- 管道运算符 ( `|>`) 优雅地链接这些转换，从而增强代码的可读性。

**请记住，管道运营商** **仍处于 TC39 第 2 阶段的“草案”。**

# 记录和元组

这些不可变数据结构分别类似于对象和数组，但创建后无法修改。例如，更新记录或元组会产生新实例：

```JS
// 创建不可变记录
const userProfile = #{ 
  username : "IgorKomolov" , 
  age : 39 , 
}; 

// 创建一个不可变元组
const numberSequence = #[ 10 , 20 , 30 ]; 

// 更新这些结构会创建新实例
const UpdatedProfile = userProfile.与（{年龄：40 }）；
安慰。日志（更新的配置文件）；// #{ 用户名: "IgorKomolov", 年龄: 40 } 
console .日志（用户配置文件）；// #{ 用户名: "IgorKomolov", 年龄: 39 } (保持不变) 

const newNumberSequence = numberSequence.与( 1 , 25 );
安慰。日志（新数字序列）；// #[10, 25, 30]
控制台.日志（数字序列）；// #[10,20,30]（保持不变）
```

记录的功能类似于对象，元组类似于数组。然而，它们的定义特征是不变性。

记录和元组可以增强某些情况下的性能并强制代码库中的不变性。虽然它们处于提案的第二阶段，尚未在 JavaScript 引擎中实现，但开发人员可以使用 Babel 等转译器进行实验。

# 装饰器

感谢 TypeScript 提供的这个功能，期待已久，现在开箱即用！它们允许修改或增强类、方法、属性或参数的行为。它们对于以声明方式添加元数据、日志记录或修改行为特别有用：

```JS
// 应用装饰器来跟踪方法的执行
class  SampleClass { 
  @trackExecution 
  PerformAction ( parameter1,parameter2 ) { 
    // 这里是方法实现
  } 
}
```

在这个例子中：

- `SampleClass`是正在定义的类。
- `@trackExecution`是用于记录或跟踪对方法的调用的装饰器`performAction`。
- `performAction``SampleClass`是其中带有两个参数 (`parameter1`和)的方法`parameter2`。装饰器将记录或跟踪对此方法的每次调用。

# 模式匹配

此功能引入了一种简洁的语法，用于解构和匹配复杂的数据结构，增强代码可读性并减少样板代码。

（研究）更多内容即将推出，请稍后再回来查看！

# Temporal

尽管已经起草了一段时间，但更新后的[Temporal](https://medium.com/@yourfuse/javascript-temporal-api-078ad4c2bb60)是为 JavaScript 提出的现代且全面的日期时间 API，目前处于[第 3 阶段](https://tc39.es/proposal-temporal/)，旨在解决现有对象的许多限制和复杂性`Date`。以下是在 ES2024 中使用 Temporal 的一些示例：

该对象提供了多个工厂方法来创建当前时间的时间值。

## 获取 UTC 的当前时刻

```
Temporal.Now.instant().toString()
```

## 获取特定时区中的当前分区日期时间

```
Temporal.Now.zonedDateTimeISO('Asia/Shanghai').toString()
```

## 获取 ISO 格式的当前纯日期时间

```
Temporal.Now.plainDateTimeISO().toString()
```

## 获取 ISO 格式的当前普通时间

`Temporal.Now.plainTimeISO().toString()`。

## 的性质`ZonedDateTime.prototype`

Temporal 中的类`ZonedDateTime`具有多个属性和方法，允许对日期时间信息进行详细操作和检索。

- 其中包括日历、时区、年、月、日、小时、分钟、秒甚至纳秒的 getter。
- 它还包括`.with()`、`.add()`、`.subtract()`、`.until()`、`.since()`和等方法`.round()`，提供了处理分区日期时间值的广泛功能。

## Temporal 中的普通时间类

Temporal 引入了“普通”类，它们是没有时区的时间的抽象表示。

- 这些类包括`PlainDateTime`、`PlainDate`和`PlainTime`。
- 它们对于显示给定时区的挂钟时间或与时区无关的时间计算非常有用，例如查找 1984 年 6 月的第一个星期二。

这些示例演示了 ES2024 中的 Temporal 如何简化和增强 JavaScript 中的日期时间处理，为开发人员提供更强大、更通用的工具。

现在想使用它吗？没问题！

导入提案或使用 Babel Polyfil，以下是导入提案的方法...

```
//没错，你可以导入提案:) 
import { Temporal } from  '@std/proposal-temporal' ; 


//基本操作
const now = Temporal .现在。zonedDateTimeISO ( '美国/纽约' );
安慰。log (now.toString ( )); 

//操作和比较

const date = Temporal .普通日期。来自（'2024-01-01'）；
常量newDate = 日期。添加({天: 10 });
安慰。log (newDate.toString ( )); // 输出 '2024-01-11'
```

# 符合人体工程学的品牌检查

简化了自定义类和数据结构中对象类型的检查，使类型验证更加直观且不易出错。稍后再见样板！

## 传统方法（ES2024之前）

```JS
类 书{ 
    #author;

    构造函数(作者) { 
        this .#author = 作者; 
    }

    静态 hasAuthorField ( obj ) {
        尝试{ 
            obj.#author; // 尝试访问私有字段
            return  true ; // 访问成功
        } catch (err) { 
            if (err instanceof  TypeError ) { 
                return  false ; // 访问失败，字段不存在
            } 
            throw err; // 重新抛出其他错误
        } 
    } 
} 

// 用法示例：
const myBook = new  Book ( "Igor Komolov" );
安慰。log ( Book.hasAuthorField ( myBook )); // 预期输出：true 

const otherObject = {};
安慰。log ( Book.hasAuthorField ( otherObject )); // 预期输出： false
```

## 新的 ES2024 方法

```JS
类 BookES2024 { 
    #author;

    构造函数(作者) { 
        this .#author = 作者; 
    } 

    static  hasAuthorField ( obj ) { 
        return #author in obj; // 用于检查私有字段的新 ES2024 语法
    } 
} 

// 用法示例：
const myBook2024 = new  BookES2024 ( "Igor Komolov" );
安慰。日志（BookES2024。hasAuthorField （ myBook2024 ））；// 预期输出：true 

const otherObject2024 = {};
安慰。日志（BookES2024。hasAuthorField （ otherObject2024 ））；// 预期输出： false
```

在此示例中，该类`Book`演示了传统方法，同时`BookES2024`使用了新的 ES2024 语法。静态方法在每个类中使用不同的方法检查对象中`hasAuthorField`是否存在私有字段。`#author`

# 领域 API

该 API 提供了一种创建隔离 JavaScript 环境的机制。它对于安全代码执行和沙箱非常有用，允许您在受控和隔离的上下文中运行代码。另外，这个名字听起来太棒了！

## 创建领域并评估简单表达式

```
const igorsRealm = new  Realm (); 
igorsRealm.evaluate( '3 * 5' ); // 在 Igor 的领域中评估为 15
```

## 在领域之间共享符号

```
const igorsRealm = new  Realm ();
象征。for ( 'y' ) === igorsRealm.evaluate( 'Symbol.for("y")' ); // 返回 true，共享符号 'y'
```

## 使用自动包装函数

当可调用对象从一个领域发送到另一个领域时，会在目标领域中创建一个包装函数奇异对象。调用此包装函数时，会将调用链接到原始领域中的连接函数。

```
const igorsRealm = new  Realm (); 
const doubleFunction = igorsRealm.evaluate( 'num => num * 2' );
双功能（10）；// 返回20
```

## 带回调的函数评估

```
const igorsRealm = new  Realm (); 
const processNumber = igorsRealm.evaluate( '(number,callback) =>callback(number + 5)' ); 
processNumber ( 5 , (结果=>  console .log (结果))); // 记录 10 (5 + 5)
```

## 受限的全局上下文访问

访问全局对象（例如`globalThis`、数组）或`Object.prototype`直接通过 访问`realm.evaluate`会引发 TypeError。

```
const igorsRealm = new  Realm (); 
igorsRealm.evaluate( '这个' ); // 抛出 TypeError
 igorsRealm.evaluate( 'new Array()' ); // 抛出 TypeError
 igorsRealm.evaluate( 'Object.keys({})' ); // 抛出类型错误
```

ES2024 即将推出的功能将彻底改变我们处理 JavaScript 编码的方式。这些增强功能不仅有望提高代码的可读性和效率，而且还引入了强大的新范例，例如**不可变数据结构**和**高级模式匹配**。随着这些功能从提议转向实现，它们为开发人员编写更清晰、更易于维护且更具表现力的 JavaScript 代码开辟了新的可能性。 JavaScript 的未来因这些进步而显得光明，标志着这种语言的持续发展，它已成为现代 Web 开发的基石。