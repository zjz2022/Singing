## 网站攻击

**1.CSRF攻击**

​		 跨站请求伪造是一种对网站的恶意利用，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 CSRF跨站点请求伪造(Cross—Site Request Forgery) 跟XSS攻击一样，存在巨大的危害性。**https 不能防范 csrf 攻击。**

```
攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账
```

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

两个条件：

1. C 用户访问站点 A 并产生了 cookie
2. C 用户没有退出 A 同时访问了 B

防御：

1. 利用Http 的 Refer 字段

​		根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址 。在通常情况下，访问一个安全受限页面的请求来自于同一个网站。因此，要防御 CSRF 攻击，网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。

1. 在请求地址中添加 token

​		CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于 在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中 。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

优点：这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中 ，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 ，这样就把 token 以参数的形式加入请求了。

缺点：

​		但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。		该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 token 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。

1. 在 http 中自定义属性并验证

​		这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。

缺点：

​		然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。

**2.XSS攻击**

​		跟跨网站脚本(XSS)相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

​		XSS攻击是指攻击者通过执行恶意脚本来攻击Web应用程序，从而在受害者的浏览器中执行恶意代码。XSS攻击可以分为三种类型：存储型XSS和反射型XSS。存储型XSS是指攻击者将恶意脚本存储在Web应用程序的数据库中，当用户访问包含恶意脚本的页面时，恶意脚本会被执行。存储型XSS攻击通常发生在留言板，评论区等需要用户输入内容的地方。反射型XSS是指攻击者将恶意脚本作为参数发送给Web应用程序，Web应用程序将恶意脚本反射给用户的浏览器，从而执行恶意代码。反射型XSS攻击通常发生在搜索框，登录框等需要用户输入内容的地方。DOM XSS基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。DOM 型 XSS 跟前两种 XSS 的区别：**DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞**。

​		作为一种HTML注入攻击，XSS攻击的核心思想就是在HTML页面中注入恶意代码，而XSS采用的注入方式是非常巧妙的。在XSS攻击中，一般有三个角色参与：攻击者、目标服务器、受害者的浏览器。

​		由于有的服务器并没有对用户的输入进行安全方面的验证，攻击者就可以很容易地通过正常的输入手段，夹带进一些恶意的HTML脚本代码。当受害者的浏览器访 问目标服务器上被注入恶意脚本的页面后，由于它对目标服务器的信任，这段恶意脚本的执行不会受到什么阻碍。而此时，攻击者的目的就已经达到了。

下面我们以一段简单的JavaScript脚本为例，来描述整个XSS攻击的过程：

<script>alert(document.cookie);</script>

上面这段脚本的执行具体内容就是弹出一个对话框显示用户的Cookie信息。攻击者在向目标服务器的某个页面进行数据输入的过程中，通过正常的输入方式夹带进这段脚本。

危害：

1.窃取用户Cookie2.后台增删改文章3.XSS钓鱼攻击4.利用XSS漏洞进行传播和修改网页代码5.XSS蠕虫攻击6.网站重定向7.获取键盘记录8.获取用户信息等

防御：

通过前面的介绍可以得知，XSS 攻击有两大要素：

1. 攻击者提交恶意代码。
2. 浏览器执行恶意代码。

根本的解决方法：**从输入到输出都需要过滤、转义。**

1、对输入和URL参数进行过滤(白名单和黑名单)检查用户输入的数据中是否包含一些特殊字符，如<、>、’、“等，发现存在特殊字符，将这些特殊字符过滤或者编码。

2、富文本的事件肯定要被禁止，因为富文本并不需要事件这种东西，另外一些危险的标签也需要禁止，例如：` <iframe>，<script>，<base>，<form>`等

3、所有需要输出到 HTML 页面的变量，全部需要使用编码或者转义来防御

4、安全头，这是浏览器自带的防范能力，一般是通过开启 Web 安全头生效的。**CSP**：W3C 的 Content Security Policy，简称 CSP，主要是用来定义页面可以加载哪些资源，减少 XSS 的发生。**X-XSS-Protection**：IE 提供的一些 XSS 检测与防范，默认开启

5、HTTP-only Cookie。攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。

https://zhuanlan.zhihu.com/p/61773197



**3 中间人攻击（MITM）**

​		中间人攻击本质上是窃听攻击。举个例子，小明用微信发一条消息给小红，这条消息会从小明的手机发送到微信的服务器，再由微信服务器转发给小红，理论上讲，微信服务器是可以查看或者修改小明发送的信息的。这个时候，微信服务器就可以是实施攻击的中间人。

​		攻击流程（Fiddler抓包为例）：

- 黑客通过特殊途径在被攻击者的手机上安装根证书；
- 客户端发起连接请求，代理服务器（Fiddler）在中间截取请求，返回自己签名的伪造证书；
- 客户端收到证书后会在系统中查找信任的根证书，因为黑客已经事先在被攻击者手机上安装了自己的根证书，因此客户端验证通过；
- 客户端后续就会把Fiddler当成合法的服务器；
- 而Fiddler会与真实的服务器通信，截获密钥，解密数据。

​		对https：

​		对于https来说，客户端或者操作系统内置了权威CA(certification authority)的根证书，而服务器在通信之初，会先返回在CA那里获取的签名证书，然后客户端用根证书验证证书有效性，最后使用验证通过的证书提供的公钥加密数据。前提假设是权威的证书机构不会把签名信息泄露出去。

​		早年12306非得使用自己签名的证书，而主流浏览器又不认可，导致用户需要在首次下载证书并安装。这其实是个很危险的操作，不法分子完全可以利用这个机制把非法证书安装到用户设备上。好在现在12306已经采用DigiCert颁布的证书了。