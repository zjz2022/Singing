# 事件循环机制

## 6.1 什么是浏览器事件循环

Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。

当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)，其运行原理如下图所示。

![在这里插入图片描述](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/d41cb74e85354e58858c71a6af8f79c8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp) 从左到右，从上到下，Node.js 被分为了四层，分别是 应用层、V8引擎层、Node API层 和 LIBUV层。

- **应用层**：   即 JavaScript 交互层，常见的就是 Node.js 的模块，比如 http，fs
- **V8引擎层**：  即利用 V8 引擎来解析JavaScript 语法，进而和下层 API 交互
- **Node API层**：  为上层模块提供系统调用，一般是由 C 语言来实现，和操作系统进行交互 。
- **LIBUV层**： 是跨平台的底层封装，实现了 事件循环、文件操作等，是 Node.js 实现异步的核心 。

在Node中，我们所说的事件循环是基于libuv实现的，libuv是一个多平台的专注于异步IO的库。上图的EVENT_QUEUE 给人看起来只有一个队列，但事实上EventLoop存在6个阶段，每个阶段都有对应的一个先进先出的回调队列。

## 6.2 事件循环的六个阶段

事件循环一共可以分成了六个阶段，如下图所示。 ![在这里插入图片描述](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/9dea7d0107f446fb8b75f56bbe60d9cetplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

- timers阶段：此阶段主要执行timer（setTimeout、setInterval）的回调。
- I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。
- 闲置阶段(idle、prepare)：仅系统内部使用。
- 轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。
- 检查阶段(check)：setImmediate() 回调函数在这里执行
- 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)

每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段，如下图所示。 ![在这里插入图片描述](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/c641dbe328574fc5ad3d2c3ab47f0338tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)



作者：xiangzhihong
链接：https://juejin.cn/post/7028781282683256869
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。