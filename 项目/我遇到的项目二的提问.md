# 项目介绍

**RealTime Messenger**

- 项目概述：一个实时聊天程序
- 前端：Nextjs，TypeScript，Tailwind CSS，NextAuth
- 后端：Prisma，Pusher，MongoDB

2024年2月2024年3月

- 主要功能
  - 使用Pusher进行实时消息传递
  - 使用NextAuth进行凭证身份验证，谷歌身份验证集合，Github身份验证集成
  - 使用Cloudinary CDN上传文件和图像
  - 使用reacthookform进行客户端表单验证和处理，使用reacttoast处理服务器错误
  - 消息已读回执，用户在线/离线状态，群组聊天和一对一消息传递

# 如何做的技术选型

## 前端

## nextjs

Next.js 是一个基于React的开源JavaScript框架，主要用于构建服务器渲染和静态生成的web应用程序。Next.js 有以下一些主要好处：

1. 服务器端渲染（Server Side Rendering）：Next.js 允许你在服务器端预渲染React组件，这可以提高首次加载时的性能，并且对SEO非常有益，因为搜索引擎抓取器可以更容易地解析服务器渲染的HTML。

2. 静态站点生成（Static Site Generation）：Next.js 不仅支持SSR，也支持静态网站生成。这意味着你可以构建完全静态的网站，这些网站可以被CDN分发，从而提供更快的内容传递速度。

3. 文件系统路由：Next.js 使用文件系统进行页面路由。在pages目录下创建的每一个file都自动地成为一个路由。这使得构建和扩展大型项目简单直接。

4. 内建CSS支持：Next.js允许你直接在组件中导入CSS文件，或使用JSX样式，无须配置任何额外的加载器。

5. 热代码替换（Hot Module Replacement）：Next.js 实现了开箱即用的热代码替换，这意味着当你在开发时修改了代码，你的应用程序会即时刷新来应用这些更改。

6. 零配置：Next.js 默认配置用于最常见的cases，从而降低了设置项目的复杂性。但如果需要，你也可以稍加修改来满足你的特定需求。

7. API路由：除了前端页面路由，Next.js还支持创建API路由，使其可以作为后端服务器用来处理HTTP请求。

8. TypeScript支持：Next.js 默认支持TypeScript，只需简单配置即可使用，无需安装额外插件。

选用Next.js和TypeScript，是因为Next.js是一个功能齐全的React框架，可以进行SSR，也支持与Vercel无缝集成。而使用TypeScript是为了强类型、自动补全和代码的健壮性。Tailwind CSS则提供了高度可定制的实用工具类，可以快速编写自定义UI。

## Prisma

Prisma 是一个开源的下一代ORM（对象关系映射）工具，它能帮助开发人员在 Node.js 和 TypeScript 项目中轻松处理数据库。使用Prisma的理由有以下几个：

1. 类型安全：Prisma 提供的客户端是完全类型安全的，由原生TypeScript 实现。数据库的模式被映射到TypeScript类型，这样能够获得类型提示，并在编译阶段就可以发现潜在的错误。

2. 易于理解的查询语言：Prisma 提供了一个更现代、更直观的查询语言，让你可以构建更复杂的查询，而无需写复杂的SQL语句。

3. 自动迁移工具：Prisma 提供了Prisma Migrate，用于版本控制和数据库模式迁移。你可以定义模式文件，并由 Prisma Migrate 自动生成SQL迁移脚本。

4. 简洁明了的API：Prisma 提供了一个直观易懂的API，它简化了数据库操作，并且提供了强大的筛选、排序、分页等功能。

5. 性能稳健：由于 Prisma 是编译后的 Rust 代码，并且连接池管理也经过优化，所以它的性能相当稳健。

6. 适用于多种数据库：Prisma 支持多种流行的SQL和NoSQL数据库，包括 PostgreSQL、MySQL、SQLite 和 SQL Server等。

7. 主流框架友好：Prisma 可以无缝集成到主流的 Node.js 框架中，例如：Express、Koa、NestJS 和 GraphQL 等。

因此，如果你正在寻找一个可提供类型安全的、易拉直、强大且简洁的API的现代化数据库访问层，那么 Prisma 就是一个极佳的选择。

## pusher

Pusher 是一种实时通信服务，它让开发者可以在云服务中轻松实现实时通信。以下是一些关于 Pusher 的详细介绍：

实时通信的实现

Pusher 使用了 WebSocket 技术，这是一种能在单个 TCP 连接上进行全双工通信的协议。它将信息推送至客户端，而不需要客户端定期检查或轮询新信息。这意味着你可以实时地将信息推送至网页、手机app等客户端。

功能

Pusher 主要提供三大功：

1. 实时消息传递：Pusher Channels 功能能让你将任何类型的实时数据推送至客户端，例如实时通知、实时表单、实时评论等。
2. 实时数据同步：Pusher Sync 功能提供了在不同设备间实时同步数据状态的能力，这对于多设备交互的应用至关重要。
3. 实时位置共享：如果你需要展示实时地理位置信息，如地图上的出租车位置、即时天气等，Pusher的Beams 功能可以很好地满足你。

使用和整合

Pusher 提供了对多种主流开发语言（如JavaScript、PHP、Python、Ruby、.NET等）的 SDK 支持，以及对多种应用框架（如 Laravel、Django、Rails 等）的插件支持。只需要按照指南在你的服务器和客户端代码中增加一些简单的配置，就可以使用 Pusher 提供的服务。

扩展性和安全性

Pusher 为大型应用考虑到了扩展性。你可以非常简单地将应用从几百个连接扩展到几百万个连接。同时，Pusher 的所有通信都是通过 SSL 进行加密的，而且提供了对私有和存在通道的授权机制。

总的来说，Pusher 是一个很强大的实时通信服务，无论是在开发新应用，还是在为现有应用添加实时功能，都能快速并且稳定地实现。

Pusher 使用 WebSocket 技术实现实时通信。

WebSocket 是一种网络通信协议，提供全双工通信能力。传统的 HTTP 协议只支持半双工通信，即客户端发送请求到服务器，然后服务器给出响应。然而，WebSocket 连接一旦建立，客户端和服务器之间就可以相互发送或接收数据，没有了请求和响应的概念。

这种全双工通信模式使得 Pusher 可以实现实时推送功能。一旦有新的数据需要发送到客户端，服务器就可以主动推送数据，无需客户端发起请求。这个特性对于需要实时数据更新的场景（如聊天应用、实时股票更新等）非常有用。

另外，Pusher 还提供了一套完整的实时通信解决方案，包括连接管理、频道订阅等功能，让开发者可以更容易的构建实时应用。

## 后端

# pusher

## API

在我之前的即时通讯项目中，我确实用到了 Pusher 的几种 API，包括 Channels API 和 Chatkit API。

首先，我使用了 Pusher 的 Channels API。它是 Pusher 的核心产品，这个 API 让我能够在应用中创建多个频道，用于实现群聊和私聊功能。我使用 pusher.trigger() 方法在服务器端发送实时消息，客户端使用 subscribe() 方法订阅服务器的实时消息，customize() 方法用来定制群频道和私频道。

接着，我也使用了 Pusher 的 Chatkit API。这个 API 提供了创建和管理用户和群组的功能。我用它来创建用户，加入和离开群组等。这对即时通讯应用非常有用，因为它省去了我自己开发用户和群组管理系统的时间。

同时，Chatkit API 还提供了消息历史记录的功能，即使客户端离线，也可以在上线时获取到离线期间的聊天记录。

以上就是我在即时通讯项目中使用 Pusher API 的情况。由于使用了 Pusher 的服务，项目开发中的很多复杂问题都被简化，我可以专注于业务逻辑的实现，提高了工作效率。

## 介绍一下心跳机制

心跳机制常被用于实时通信中，用于持续检测和确保客户端和服务器之间的连接仍然有效。简单的形式是，客户端周期性地向服务器发送特定请求，，表示它“仍然活着”，服务器收到这个请求后返回确认消息。如果在设定的时间内没有收到心跳，就认定连接已经断开。

## websocket

WebSocket是一种网络通信协议，它在单个TCP连接上提供全双工通信通道，能够实现客户端与服务器之间的实时双向交互。通过WebSocket，服务器可以主动向客户端推送信息，而在HTTP协议中，只能由客户端主动发起请求。

## 消息已读

 通常消息“已读”标记会在用户打开或者查看消息后由客户端发送给服务器，然后服务器更新消息状态。这个需求的实现具体取决于你的应用是如何处理和存储消息的。

## pusher原理

Pusher 应用 WebSocket TCP 长连接供实时双向通信。Pusher 得以将实时事件分发到客户端，这些客户端订阅了这些事件。后端服务触发事件，它们会带着关联数据被分发到所有的订阅客户端。

## 说说websocket

前后端交互通常有 HTTP 和 WebSocket 2 种通讯方式

WebSocket 是 HTML5 标准的一部分，它提供了**全双工**的通信通道。一次握手后，客户端和服务器之间的所有通信都是持久的、双向的，比传统的 HTTP 请求更有效率。

## 断开连接怎么办

对于互联网应用，连接断开是必然会碰到的问题。常见的处理方式是重连机制。例如，如果发现 WebSocket 断开，可以尝试自动重新创建一个新的 WebSocket；或者，在使用 Pusher 这样的服务时，可以利用其提供的自动重连功能。

## 用户的在线离线状态是怎么去处理的呀（滴滴）

一种常见的方法是采用心跳机制，即客户端定期向服务器发送信号，表明它仍然在线，如果服务器在一段时间内没有接收到来自客户端的信号，那么就认为客户端已经离线。在使用 Stomp 或 Socket.io 这样的库时，这个功能通常已经内置完成。

## 消息已读怎么做

对于已读回执，我们可以在用户查看了消息后，向后端发送一个确认的请求，然后在数据库中标记该消息为已读。同时，我们也可以通过Pusher，将这个信息推送给消息发送者。

一种常见的实现方式是，当用户打开聊天应用并读取了新消息后，发送一个请求到服务器，说明用户已经读取了这些消息。服务器接收到这个请求后，可以更新这些消息的状态，然后通过 WebSocket 或其他实时通信工具告诉其他用户这些消息已被读取。

## pusher是怎么进行通信的，原理是什么

Pusher在后端服务和客户端之间建立一个Websocket连接，实现全双工的实时数据传输。当后端产生新的消息时，可以通过Pusher发出一个事件，所有监听这个事件的客户端都能够接收到这个事件和相关的数据。

Pusher 应用 WebSocket TCP 长连接供实时双向通信。Pusher 得以将实时事件分发到客户端，这些客户端订阅了这些事件。后端服务触发事件，它们会带着关联数据被分发到所有的订阅客户端。

## 用户在线，离线状态，是怎么处理的？后端的逻辑是怎么判断用户是离线还是在线的？

### 在线离线

在此应用中，我们使用了Pusher的Presence Channels来跟踪用户的在线状态。当用户订阅特定的Presence Channel时，我们视为用户在线；当他们取消订阅或断开连接时，我们视为用户离线。

原理：在实时聊天程序中，通常我们可以使用websocket来持续追踪用户的在线状态。当用户加载应用的时候，会建立一个到服务器的websocket连接，此时用户在线；当websocket连接断开时，用户离线。

Pusher这样的实时通讯服务解决方案来处理用户在线离线状态。

### 后端逻辑

在后端，我们可以通过检测用户的活动状态或者监听特定的网络事件来判断用户是否在线。

1. 检测用户的活动状态：在这种方法中，通常采用 session 或 token 的方式。当用户成功登录后，后端会创建一个 session 或者生成一个 token，然后这个 session 或 token 会被发送给前端并存储在用户的本地中，如 cookie。在后续的每个请求中，这个 session 或 token 都会被提交到后端，后端通过检查 session 或 token 有效性来确定用户是否在线。

2. 监听网络事件：当用户的浏览器关闭了与服务端的连接，服务端会接收到一个网络事件，例如 WebSocket 连接断开事件，通过这个可以知道用户已经离线。

对于使用了 Pusher 服务的项目，Pusher 提供了 Presence Channels 功能，使得我们可以在用户连接和断开连接时接收到事件通知，进而得知用户的在线状态。

具体实践中，服务端的逻辑可能会去结合使用上述方法来获取比较准确的用户在线状态。

## 介绍下实时通信项目，pusher，重连机制，用pusher的好处是什么，详细讲讲websocket（太细啦，感觉被扒光光）

Pusher是一种实时通信服务，它提供了WebSocket接口来让你的应用实时地接收服务端消息。Pusher的好处是你无需自建实时通信服务器，直接使用它的API即可实现需要的功能。如果连接中断，Pusher 库会自动尝试重新连接。WebSocket是一种网络通信协议，它在单个TCP连接上提供全双工通信通道，在客户端和服务器之间，可以实现实时双向数据传输。

# 数据库

## 后端的表是怎么设计的

这部分要具体查看项目的需求，但是对于聊天应用，一般我们需要这样的数据库表：一个User表来存储用户信息，接着需要一个Conversation表来存储每个聊天会话信息，再有一个Messages表来存储消息内容，可能还包括发送者，接收者，时间戳等信息。除此之外，可能还需要一个Participant表，来记录哪些用户在哪个会话中。

## 为什么要用mongodp数据库，mysql用过吗

 MongoDB作为一个NoSQL数据库，对于非关系型的数据存储，比如聊天数据，具有一些天然的优点。比如其灵活的存储结构可以更自然地匹配聊天信息的结构，而且在处理大量读写，支持高并发的场景下表现优异。而MySQL是关系型数据库，对于关系复杂，需要复杂SQL查询，数据一致性要求高的场景更加适合。

# NextAuth

## 登录是怎么做的，jwt相关，以及cookie，session相关，太细啦！

用户登录成功后，服务器端会使用用户信息，加上一个密钥生成JWT令牌，然后将这个令牌发给客户端。客户端收到令牌后，可以把它存储在本地（例如localStorage或cookies）然后每次向服务器发送请求时，都带上这个令牌。服务器收到这个令牌后，会用之前的密钥去解码，如果能正确解出用户信息，那说明这个JWT是合法未被篡改的，用户是已登录状态。

## 除了用jwt还有其他方案嘛

除了JWT，还有sessioncookie验证方式。这种方式用户登录成功后，服务器会生成一个session ID然后发给客户端，客户端将session ID存储在cookie中，之后每次发起请求，都会带上这个session ID。

## 登陆注册怎么做的 （ jwt相关）

 该应用使用NextAuth进行用户认证。NextAuth支持多种认证方式，包括基于JWT（JSON Web Tokens）的认证和OAuth（开放授权）等。在用户登录系统时，NextAuth会在服务端验证用户的身份，并将生成的JWT令牌发送到客户端，之后，客户端可以利用这个令牌来进行受保护的操作。

## 说说cookie和localstorage

Cookie是由服务器发送到用户浏览器并保存在浏览器上的一种技术，主要用于在用户的电脑上保存少量信息。它的大小通常限制在4KB左右，而且有生命周期，过期后会被自动删除。每次当前用户向服务器发送请求时，都会自动携带这个cookie。

localStorage是HTML5新增的API，它用于永久性地保存大量数据（最大存储量5MB）在客户端。它并不会随着每次请求自动发送到服务器，适合保存仅供客户端使用的数据。

## 回到前面的问题，用户的登录状态是怎么存储在服务器端的（在 Redis 中用 HashMap，我滴汗，不是前端面试嘛）

在服务器端，你可以使用Redis这样的内存数据库来存储用户的session，每个session对应一个HashMap，里面存有用户的登录状态和其他需要的信息。当用户发来请求时，服务器根据请求中的session ID在Redis中查找相应的session数据，以此判断用户的登录状态。

## next auth是怎么做身份校验的

 NextAuth提供了同时进行社交登录和基于JWT的认证的功能。在用户进行登录操作时，NextAuth会根据用户的认证方式，生成一个包含用户信息的JWT，存储在Cookie中，在用户之后的请求中，NextAuth会验证这个JWT的合法性，从而确认用户的身份。

## 第三方授权的无限递归错误？

这种情况一般来说是因为存在反复重定向导致的，在用户进行第三方授权，比如使用 Google 或者 GitHub 登录的时候，如果授权成功后的回调 URL 配置不正确，可能会发生这样的问题。例如，你设置的回调 URL 又导向了开始的授权 URL，就会形成无限的递归导致错误。解决此问题，我们需要确保回调 URL 是导向我们自己的服务器，然后在服务器端正确处理第三方传回的授权信息。

## 第三方登录你是怎么做的，有做微信登陆嘛

 第三方登录可以通过OAuth认证协议来实现。对于微信登录，先在微信开放平台注册开发者账户并创建应用，获取应用的AppID和AppSecret，然后在你的应用中加入"微信登录"的按钮，当用户点击后，引导他们到微信的授权页面。用户同意授权后，微信会回调你在平台上设置的回调地址，同时给你一个授权码。你的服务器使用这个授权码，再加上你的AppID和AppSecret，向微信服务器发起请求，获取access_token和用户的openid，然后就可以获取到用户的微信信息了。

## 双token登陆有做过吗 

 双token登陆，就是指access token 和 refresh token。access token主要用于用户访问资源。但是访问令牌具有较短的生命周期，一旦过期，用户就需要重新登录。但是，为了更好的用户体验，这时候就可以使用refresh token。用户在第一次登录成功后，服务端会返回一个access token和一个refresh token。当access token过期时，用户可以使用refresh token向服务器请求新的access token，从而无需重新登录。这种方式很常见于移动应用程序中。

# CDN

## 你这个cdn是干嘛的

Content Delivery Network（内容分发网络），是用于将网站内容分发到多个地点，以便用户可以就近获取内容，从而提高网站速度和性能。在我们的应用中，用户的图片和文件上传到了Cloudinary这个CDN，因此无论用户在哪里，都能够快速地加载和查看这些内容。

## 为什么要用cdn

CDN 极大地提高了访问速度及数据的稳定性。对于图片、视频这样的大数据元素，通过 CDN 可以加快加载速度，提升用户体验。同时也小心节省了服务器的流量。

# react-hook-form你是怎么用的

 Reacthookform是进行表单验证的React库。它使用React Hook，使用非常方便。我们使用它来收集用户输入的信息，并进行验证，如果用户的输入不满足要求，Reacthookform可以显示错误消息，并阻止表单提交。

# react-toast你是怎么处理错误的

在前端，我们使用了reacttoast来处理和展示服务器返回的错误消息。如果请求成功，我们通常会立即对页面进行更新；如果请求失败，则会通过reacttoast在屏幕上显示一条提示消息，告知用户操作结果和失败的原因。

# 移动端适配

## 做过移动端适配吗

对于前端项目，可以使用媒体查询（Media Queries）和响应式设计（Responsive Design）来确保内容在不同尺寸的屏幕上都能正确显示。而对于 Next.js 这样的服务器渲染框架，一些库（例如 Styled JSX）允许你在组件中直接编写包含媒体查询的 CSS。

# 网站实时在线人数

这篇文章介绍了如何实现网站实时在线人数的功能，包括当前正在阅读某篇文章的人数。作者选择了 WebSocket技术，使用 Socket.IO （WebSocket 的上层封装） 进行实现。实时人数统计基于 WebSocket 连接数，但为避免重复计数（同一用户打开多个页面），采用了在客户端生成唯一 SessionId 的方法，并将其存储在 LocalStorage 中。服务端则通过传递的 SessionId 进行去重，确保在线人数的准确性。此外，文章还详细讨论了如何利用 Socket.IO 的 Room 功能实现文章实时阅读人数的统计和读者阅读进度的实时展示。所有实现代码均已开源。

https://cn.innei.ren/posts/devstory/howistherealtimeheadcountatthesiteachieved

# 跨域

## 问点网络相关的问题，你是怎么理解跨域的（开始吟唱）

当一个脚本尝试从一个源（域名，协议，甚至端口）请求另一个源的资源时，就会发生跨域。出于安全原因，浏览器实行同源策略不允许跨域能直接请求资源。但有几种常见的方式能"绕过"这个限制，如JSONP，CORS，还有设置代理等。

## 在不同的环境下如何做跨域处理（Proxy）

对于开发环境，常见的做法是在本地启用一个代理服务器。例如，webpackdevserver就提供了一个代理功能，能将特定的URL前缀代理到真实的后端服务器。而在生产环境下，跨域问题通常由后端通过设置CORS头来解决，或者前后端使用同一域名，通过Nginx等服务器反向代理到相应的前后端服务器。

# 浏览器缓存

## 说说浏览器缓存，强缓存和协商缓存，LastModified和Etag优先级哪个更高，强缓存和协商缓存呢？

  浏览器缓存分为强缓存和协商缓存。强缓存根据HTTP 头部的 Expires 或 CacheControl 判断一个资源是否可以使用，而协商缓存则是通过 LastModified 或 Etag 来判断资源是否有更新。对于它们的优先级，通常 Etag 的优先级 > LastModified，而强缓存优先级高于协商缓存。

# 网络攻击

## 你刚刚提到jsonp的xss攻击，详细说说

因为JSONP是通过插入script标签来实现的，这就给攻击者一个机会：如果攻击者控制了你请求的URL，那么他们就可以在你的页面中插入恶意脚本。

# 逻辑

## 你这些逻辑，比如说服务端逻辑，你是写在哪的呀（滴滴）

## 后端是用TS写的吗？那你如果要去判断用户离线还是在线，后端肯定是要有逻辑的嘛，这逻辑是怎么写的呀（滴滴）

# 框架

## 你的项目有用到什么框架吗？Vue或者React

你熟悉哪个我就问你哪个
