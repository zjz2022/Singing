### 缓存

​		浏览器缓存指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。

HTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略。

HTTP缓存可以缩短网页请求资源的距离，减少延迟，节省网络流量，并且由于缓存文件可以重复利用，降低网络负荷，提高客户端响应。缺点是服务端更改内容不能及时同步到客户端。

根据是否需要重新向服务器发起请求，可分为**强缓存和协商缓存**

**1 强缓存**

定义：当命中强缓存的时候，客户端不会再请求服务器，直接从缓存中读取内容，并返回HTTP状态码200。

强制缓存，在响应头由 Expires、Cache-Control 和 Pragma控制

```
Expires：值为服务器返回的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。（HTTP1.0的属性，缺点是客户端和服务器时间不一致会导致命中误差）(绝对时间)
Cache-Control：HTTP1.1属性，优先级更高，以下为常用属性
	no-store： 禁用缓存
	no-cache：不使用强缓存，每次需向服务器验证缓存是否失效
	private/public：private指的单个用户，public可以被任何中间人、CDN等缓存
	max-age=：max-age是距离请求发起的时间的秒数(相对时间)
	must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证
Pragma
	no-cache：效果和cache-control等no-cache一致。
	优先级Pragma > Cache-Control > Expires
```

**知道 from disk cache和from memory cache吗，他们都是什么时候会触发？**当强缓存的时候会触发这个， 浏览器缓存是存储在磁盘和内存中，当需要使用到缓存的时候会先从内存查找，没有查找到就从磁盘中查找。如果还是找不到就向服务器请求，得到数据再存到内存和磁盘。

**如何刷新强缓存**从上面的强缓存知识中，知道如果缓存时间没有过，我们一直都是在缓存中拿数据的，那么当我们把服务器的数据更新，如何让强缓存也能拿到最新的数据。因为强缓存都是判断url来判断是从缓存中拿数据还是从服务器拿数据，所以只要我们更改了这个url就可以。例如我们在url的后面添加一个version版本或者使用hash来让原来的url改变就可以刷新浏览器的缓存了。

**2 协商缓存**

定义：向服务器发送请求，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源。

协商缓存，响应头中有两个字段标记规则

```
Last-Modified / If-Modified-Since
	Last-Modified是浏览器第一个请求资源，服务器响应头字段，是资源文件最后一次更改时间(精确到秒)。
	下一次发送请求时，请求头里的If-Modified-Since就是之前的Last-Modified
	 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304且不返回资源、不返回last-modify，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.

Etag / If-None-Match：Etag 的校验优先级高于 Last-Modified
	Etag是加载资源时，服务器返回的响应头字段，是对资源的唯一标记，值是hash码， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。
	浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到请求头里的If-None-Match里
	服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。
```

**缓存验证流程**

1 ) 浏览器创建了一个请求, 首先请求到达的地方是在本地缓存, 当然是建立在有Cache-Control头的情况下如果在本地缓存里查找，如果找到，则直接返回给浏览器渲染页面这种情况下, 不会经过任何网络的传输，也就是from memory cache的效果2 ) 如果没有找到，就会去网络请求，在网络请求中，如果经过代理服务器(代理缓存)那么首先会在代理服务器上查找相关缓存信息, 如果找到就会返回给客户端经过本地缓存，再返回给浏览器渲染页面3 ) 如果在代理服务器上没有找到该缓存信息，那么就直接去源服务器上查找资源获取了新的内容之后，再逐级向下进行返回和二次缓存最终返回给浏览器进行页面的渲染

**为什么还要使用ETag呢？** 主要是为了解决Last-Modified 无法解决的一些问题：

- 某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。
- 某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。
- 一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。

https://blog.csdn.net/Tyro_java/article/details/122952039

**协商缓存失效怎么办？**

1. **服务端配置问题**：确保服务端正确地设置了Etag或者Last-Modified响应头，且在收到含有If-None-Match或If-Modified-Since请求头的请求时，能正确地返回304状态码。
2. **网络问题**：一些网络设备或软件可能会修改或移除这些头部信息，导致协商缓存失效。在这种情况下，你可能需要联系你的网络服务提供商或检查你的网络设备和软件配置。
3. **浏览器问题**：不同的浏览器可能在处理协商缓存时有不同的行为。确保你的代码和配置在你的目标浏览器上可以正常工作。

如果协商缓存无法正常工作，你可以采取以下步骤进行调试：

1. **查看网络请求**：在浏览器的开发者工具中查看网络请求，检查请求和响应头部是否正确。查看服务器是否在响应中发送了Etag或Last-Modified，以及是否正确处理了If-None-Match或If-Modified-Since请求头。
2. **查看服务器日志**：服务器的日志可能包含关于请求和响应的有用信息。如果服务器支持，你也可以在服务器上开启详细的日志记录。
3. **检查服务器配置**：确保你的服务器配置正确，并且支持协商缓存。你可能需要查阅你的服务器文档，或者联系你的服务器供应商。

如果问题仍然无法解决，你可能需要寻求专业的帮助，或者考虑使用一种不同的缓存策略。

**3 启发式缓存**

​		只有在没有明确缓存策略时，会激活启发式缓存。所以要合理设置缓存，否则会因没有设置缓存时间等原因，导致内容缓存不刷新。



**接口数据缓存在浏览器**

缓存数据的场景分为两种：

- 与用户无关的数据
- 与用户相关的数据

需要使用缓存的接口是无参数且为get类型的请求

1. 对于用户无关的数据，可以存储在localStorage中
2. 对于用户相关的数据，可以存储在sessionStorage中
3. 不修改原有的接口使用方法，创建一个新的接口调用函数，并使调用方式保持不变
4. 调用该方法时，先创建用于保存的key，再在对应的storage中查找是否有该key的缓存值，有则返回一个伪造的axios请求的Promise结果对象
5. 没有缓存时请求到数据后需要将响应数据保存在本地存储中，并且需注意的是要对请求结果做判断，只保存成功拿到数据的结果，否则一次失败后将无法再获取成功的结果
6. 创建用于缓存数据到localStorage的key时，使用了LOCALSTORAGE_CACHE_VERSION常量，该常用是使用webpack.DefinePlugin插件注入的值，这样是为了让每次重新发版后可以自动刷新本地缓存的数据
7. 创建sessionRequest方法来请求用户相关的数据，与localRequest的区别在于key的创建
8. 关于session缓存用户相关的数据，如果没有userId可供使用，可以使用一个全局的key来代替，确保该key会随着页面的刷新而变化即可，比如可以用进入页面后的某个时间点的时间戳
9. 清除旧的localStorage缓存，由于浏览器对localStorage的大小是有限制的，所以在发版后对于先前保存的数据应当予以清除

参考：

- 接口数据缓存在浏览器 https://juejin.cn/post/7086056735588220958
- https://juejin.cn/post/7074924039348699167