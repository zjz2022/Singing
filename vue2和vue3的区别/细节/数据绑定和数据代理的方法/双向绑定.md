## 双向绑定

​		vue是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。

​		首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。

​		因此接下去我们执行以下3个步骤，实现数据的双向绑定：

​		（1）实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。		（2）实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。		（3）实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。

![img](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/v2-f356f2023758b0a503e4200596f941de_720w.webp)

### 5.1 Vue2

1. 基于Object.defineProperty，不具备监听数组的能力，需要重新定义数组的原型来达到响应式。
2. Object.defineProperty 无法检测到对象属性的添加和删除 。需要使用this.$set(this.data,”key”,value’)
3. 由于Vue会在初始化实例时对属性执行getter/setter转化，所有属性必须在data对象上存在才能让Vue将它转换为响应式。
4. 深度监听需要一次性递归，对性能影响比较大。
5. 数组是通过覆盖原型对象上的7个⽅法进行实现。如果通过下标去修改数据，Vue 同样是无法感知的。也要使用特殊的 API 处理。
6. 无法处理像 Map、 Set 这样的集合类型。
7. 带有响应式状态的逻辑不方便复用。数组变异		Object.defineProperty方法可以监听数组中某个索引值的变化，但是无法监听push等方法，同时由于数组长度不固定无法监听后期添加的元素。vue2从 Array.prototype 中继承了数组方法，再通过遍历对数组方法进行重写，在新方法中实际调用原型方法并添加额外功能。

### 5.2 Vue3

1. 基于Proxy和Reflect，可以原生监听数组，可以监听对象属性的添加和删除。
2. 不需要一次性遍历data的属性，可以显著提高性能。
3. 因为Proxy是ES6新增的属性，有些浏览器还不支持,只能兼容到IE11 。

```js
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key)
      return target[key]
    },
    set(target, key, value) {
      target[key] = value
      trigger(target, key)
    }
  })
}

function ref(value) {
  const refObject = {
    get value() {
      track(refObject, 'value')
      return value
    },
    set value(newValue) {
      value = newValue
      trigger(refObject, 'value')
    }
  }
  return refObject
}
```

- 当将一个响应性对象的属性解构为一个局部变量时，响应性就会“断开连接”。因为对局部变量的访问不会触发 get / set 代理捕获。
- 在 `track()` 内部，我们会检查当前是否有正在运行的副作用。如果有，就会查找到存储了所有追踪了该属性的订阅者的 Set，然后将当前这个副作用作为新订阅者添加到该 Set 中。 副作用订阅将被存储在一个全局的 WeakMap<target, Map<key, Set<effect>>> 数据结构中。如果在第一次追踪时没有找到对相应属性订阅的副作用集合，它将会在这里新建。这就是 getSubscribersForProperty() 函数所做的事。
- 在 `trigger()` 之中，我们会再次查找到该属性的所有订阅副作用并全部执行。 这些副作用就是用来执行 diff 算法，从而更新页面的。

```js
//简单实现
0. 副作用函数。
	0.1 cleanup 当同一个副作用函数被多个响应式对象依赖时，需要每次在副作用函数执行前将其从与之关联的集合中删除。
	0.2 副作用函数发生嵌套时，内层副作用函数会覆盖activeEffect的值，因此需要引入effectStack保证嵌套的准确性。
1. 首先创建一个存储副作用函数的桶bucket，定义为Set类型。
	1.1 通过全局变量activeEffect存储被注册的副作用函数，这样即便副作用函数是匿名函数也可以被收集；
	1.2 利用set作为桶会导致副作用函数与被操作目标之间不能建立明确的关系。因此利用weakmap的键作为原始对象，值由set收集副作用函数。
	【注】：Weakmap对key是弱引用，其键只能是Object，不影响垃圾回收器的工作。一旦key被回收，对应的键和值就访问不到了。如果使用map，即便用户对目标对象没有任何引用，这个目标对象也不会被回收，会导致内存溢出。
2. 使用Proxy代理data，并配置get(),set()拦截函数，当get执行时将副作用函数添加到bucket中(trick)，当set执行时，通过forEach取出副作用函数并执行(trigger)。
	2.1 避免递归。在trigger动作发生时增加守卫条件，当trigger触发的effect()与当前执行的相同，则不执行；
```

## 