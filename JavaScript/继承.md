## 继承

### 32.1 继承，优缺点 及方法有哪些？

**继承的好处**

a：提高了代码的复用性

b：提高了代码的维护性

c：让类与类之间产生了关系，是多态的前提

**继承的弊端**

类的耦合性增强了,但是开发的原则：高内聚，低耦合

### 32.2 JavaScript实现继承的方式

**原型链继承**

实现方式：将子类的原型链指向父类的对象实例

```js
function Parent(){
	this.name = "parent";
	this.list = ['坤'];
}
Parent.prototype.sayHi = function(){
	console.log('hello');
}
function Child(){

}
Child.prototype = new Parent();
let child = new Child();
console.log(child.name);	
child.sayHi();
```

**原理：**子类实例child的`__proto__` 指向Child的原型链prototype，而Child.prototype指向Parent类的对象实例，该父类对象实例的 `__proto__` 指向Parent.prototype,所以Child可继承Parent的构造函数属性、方法和原型链属性、方法

**优点：**可继承构造函数的属性，父类构造函数的属性，父类原型的属性

**缺点：**

1. 无法向父类构造函数传参；
2. 共享父类实例的属性（若父类共有属性为引用类型，一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化）

```js
var a = new Child();
var b = new Child();
a.list.push('rap');
console.log(b.list); // ['坤','rap']
```

**构造函数继承**

实现方式：在子类构造函数中使用call或者apply劫持父类构造函数方法，并传入参数

```js
function Parent(name, id){
    this.id = id
    this.name = name
    this.printName = function(){
    	console.log(this.name)
    }
}
Parent.prototype.sayName = function(){
	console.log(this.name)
};
function Child(name, id){
	Parent.call(this, name, id) // Parent.apply(this, arguments);
}
var child = new Child("坤", "1")
child.printName() 	// 坤
child.sayName() 	// Error
```

**原理：**使用call或者apply改变子类函数的作用域，使this执行父类构造函数，子类因此可以继承父类共有属性

优点：可解决原型链继承 **共享** 的问题

缺点： 不可继承父类的原型方法，构造函数不可以被复用

**组合继承**

**原理：**综合使用构造函数继承和原型链继承

```js
function Parent(name, id){
    this.id = id;
    this.name = name;
    this.list = ['rap'];
    this.printName = function(){
    	console.log(this.name);
    }
}
Parent.prototype.sayName = function(){
	console.log(this.name);
};
function Child(name, id){
	Parent.call(this, name, id);	// Parent.apply(this, arguments);
}
Child.prototype = new Parent();
var child = new Child("坤坤", "1");
child.printName(); 	// 坤坤
child.sayName() 	// 坤坤
var a = new Child();
var b = new Child();
a.list.push('篮球');
console.log(b.list); // ['rap']    
```

**优点：**可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是私有的

**缺点：**会执行两次父类的构造函数，消耗较大内存，子类的构造函数会代替原型上的那个父类构造函数

**原型式继承**

**原理：**类似Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的 	`__proto__` 指向父对象

```js
let parent = {
	name: ['坤坤']
}
function copy(object) {
	function fn() {}
	fn.prototype = object
	return new F()
}
var child = copy(parent)
```

**缺点：** 共享引用数据类型

**寄生式继承**

**原理：**扩展原型式继承

```js
function copy(object) {
	function fn() {}
	fn.prototype = object
	return new F()
}
function createObject(obj) {
	let obj = copy(obj);
	obj.getNames = function() {
		console.log(this.names)
		return this.names
	}
	return obj
}
```

**优点：**可添加新的属性和方法

**寄生组合式继承**

**原理：**改进组合继承，利用寄生式继承的思想继承原型

```js
function inheritPrototype(subClass, superClass) {
	// 复制一份父类的原型
	let p = copy(superClass.prototype);
	// 修正构造函数
	p.constructor = subClass;
	// 设置子类原型
	subClass.prototype = p;
}
function Parent(name, id){
    this.id = id;
    this.name = name;
    this.list = ['a'];
    this.printName = function(){
    	console.log(this.name);
    }
}
Parent.prototype.sayName = function(){
	console.log(this.name);
};
function Child(name, id){
	Parent.call(this, name, id);
// Parent.apply(this, arguments);
}
inheritPrototype(Child, Parent);
```

**ES6** class extends

```js
class A {
	constructor() {
		this.a = 'hello';
	}
}
class B extends A {
    constructor() {
    	super();
    	this.b = 'world';
    }
}
let b = new B();
```

## 