## 编译渲染

**1 框架设计思想**

​		设计思想分为运行时、编译时、运行+编译时。其中运行时由于没有编译的过程会导致没办法分析用户提供的内容。而编译时的性能会更好，但是有损灵活性，如Svelte。

​		vue采取的是运行时编译的方法，内部是命令式编程而外部是声明式编程。Vue设计之初是要求性能损耗最小化，因此引入了虚拟DOM。虚拟DOM的性能：声明式更新性能损耗=找出差异的性能消耗+直接修改的性能消耗。

​		框架的大小也是衡量框架的标准之一。因此vue3设计了许多idea缩小代码体积，如：

- ​		vue的警告会配合___DEV__常量的检测，以缩小开发环境和生产环境的体积。
- ​		使用Tree-Shaking，消除永远不会被执行的代码。想要实现Tree-Shaking必须满足模块是ESM。且由于副作用函数的存在会导致很难静态的分析那些是dead code，因此出现了/***PURE\***/
- ​		为了配合vue2的API方式编程，可以通过VUE_OPTION_API_关闭，减少资源体积。

​	**2 渲染器**

​		mount钩子会在渲染器挂载完成时触发。

​		render()（也叫h()）返回一个虚拟DOM对象（vnode），包含tag、props、childern、patchFlag等属性。

​		renderer()接收vnode和container参数。其中，container是一个真实的dom(挂载点)，会将vnode挂载到上面。

```
当我们修改响应式数据时，副作用函数会重新执行完成渲染。
```

​	**3 编译器（DSL）**

​	编译器将模板内容编译成渲染函数并添加到组件对象（render()）上。为了方便寻找更新变化的量，通过编译器进行分析，并通过patchFlag配置动态属性（通过编译器找到哪些节点是变化的）。

- 词法+语法+语义分析

```
//在工程化中，webpack或vite会帮我们把用户侧的源代码拉取过来，我们使用node的readFileSync来代替这一行为。
const code =  fs.readFileSync('./vue.txt','utf-8')
//通过有限状态机，解析器能够自动的在不同的状态间进行迁移的过程，而有限则意味着状态的种类是可枚举完的。
//根据html标签的书写规则来定义状态迁移，当遇到<时，将状态标记为标签开始；伴随着while循环的执行，首次遇到非空字符时，从标签开始状态切换为标签名称状态；当遇到>时，再从标签名称状态切换为标签初始状态。至此形成一个闭环，我们在这一个闭环内记录下的状态集合则称之为一个token。
```

- 生成token流
- 生成模板AST

```
//将虚拟根作为默认的栈顶，这样在扫描实际的tokens时，就能默认作为其子节点了
//依次从tokens中取出，并判断其type类型，如果是tag则作为子节点向原栈顶追加，如果是tagEnd则从栈顶弹出
```

- 将AST转化为Js AST

```
//通过深度优先遍历进行transform(tAst,ctx)【访问者模式】
//在进行节点操作之前，我们还需要动态的给ctx挂载一些状态信息，用以标记当前transform的运行状态，比如当前运行的是哪一颗节点树、当前的节点树的父节点是谁、当前节点的兄弟节点是谁以及当前节点树是父节点的第几个子节点
```

- 将Js AST转化为render函数

```
//创建context，context上包括了若干字符串拼接相关的方法；
//对AST的codegenNode对象进行深度递归，并利用context提供的方法拼接相关字符串；
//返回结果对象，包括code属性，code属性值就是生成的render函数代码字符串。
//AST一个树形结构，每一个节点对应一个html元素
interface AstNode{
  // 元素类型,是html原生还是vue自定义
  type:string; 
  // 元素名称，是div还是h1 
  tag:string;
  // 子节点，h1是div的子节点
  children:AstNode[];
  // 开标签属性内容
  props:{
    type:string;
    name?:string;
    exp?:{
      ...
    }
    ...
  }[];
}
```

**5 卸载**

卸载发生在更新阶段（初次挂载完成后，后续渲染会触发更新）。

卸载过程：根据vnode对象获取与之关联的dom元素，使用原生的dom方法将该元素移除。不能直接使用innerHTML=''，因为容器内部可能由多个组件渲染，这么做不能正确调用钩子；它不会移除dom元素上的事件处理函数。

参考：

https://juejin.cn/post/6995232345749979172

https://juejin.cn/post/6990018362391265287